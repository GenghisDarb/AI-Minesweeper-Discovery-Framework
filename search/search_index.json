{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AI Hypothesis Discovery Framework","text":"<p>The AI Hypothesis Discovery Framework is a comprehensive toolkit designed to facilitate the development and testing of AI algorithms for systematic hypothesis exploration. It provides a robust environment for researchers and enthusiasts to explore various AI techniques and strategies, enabling them to understand and improve the performance of their algorithms in a controlled setting.</p> <p>With a focus on ease of use and extensibility, the framework offers a range of features including customizable hypothesis grids, AI agent integration, and performance analysis tools. Whether you're a seasoned AI researcher or a newcomer to the field, this framework provides the resources you need to delve into the world of AI-driven hypothesis discovery.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the framework, use the following command:</p> <pre><code>pip install ai-hypothesis-discovery-framework\n</code></pre>"},{"location":"#quick-cli-example","title":"Quick CLI Example","text":"<p>Here's a quick example of how to run a hypothesis discovery session with an AI agent using the CLI:</p> <pre><code>ai-hypothesis-discovery --agent=random --grid-size=10 --false-hypotheses=15\n</code></pre> <p>This command runs a hypothesis discovery session on a 10x10 grid with 15 false hypotheses, using a random AI agent.</p>"},{"location":"#hero-panel","title":"Hero Panel","text":"<p>\u03c7 Value: 50-digit \u03c7 = 1.41421356237309504880168872420969807856967187537694</p> <p></p>"},{"location":"#versions","title":"Versions","text":""},{"location":"#changelog","title":"Changelog","text":"v0.4 - Added TORUS-brot fractal module. - Enhanced Meta-Cell Confidence Module.  v0.3 - Initial release with Hypothesis Discovery AI."},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>Discovering \u03c6-Phase Reset</li> <li>Prime Residue Recursion</li> <li>Periodic Table Demo</li> <li>Fractal Demo: Explore the \u03c7-recursive observer-state projection and its implications in Hypothesis Discovery theory.</li> </ul>"},{"location":"#white-paper","title":"White-paper","text":"<ul> <li>What is AI-Hypothesis Discovery?</li> </ul>"},{"location":"LLM_backends/","title":"Configuring LLM Backends","text":"<p>The AI Minesweeper framework supports multiple LLM backends. Follow the instructions below to configure your preferred backend.</p>"},{"location":"LLM_backends/#openai","title":"OpenAI","text":"<ol> <li>Obtain an API key from OpenAI.</li> <li>Paste the key into the environment variable <code>OPENAI_API_KEY</code>.</li> </ol>"},{"location":"LLM_backends/#anthropic-claude","title":"Anthropic Claude","text":"<ol> <li>Obtain an API key from Anthropic.</li> <li>Paste the key into the environment variable <code>CLAUDE_API_KEY</code>.</li> </ol>"},{"location":"LLM_backends/#local-ollama","title":"Local (Ollama)","text":"<ol> <li>Ensure the Ollama server is running locally.</li> <li>No API key is required for this backend.</li> </ol>"},{"location":"LLM_backends/#none","title":"None","text":"<ol> <li>Select 'none' as the backend in the Streamlit UI.</li> <li>This option disables LLM integration.</li> </ol>"},{"location":"api/","title":"Api","text":""},{"location":"api/#src.ai_minesweeper.Board","title":"<code>Board</code>","text":"Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>class Board:\n    _history: Optional[PathHistory] = None\n\n    def __init__(\n        self, n_rows: Optional[int] = None, n_cols: Optional[int] = None, grid=None\n    ):\n        if DEBUG:\n            print(f\"[DEBUG] Board.__init__ received grid: type={type(grid)}\")\n            if isinstance(grid, list):\n                print(f\"[DEBUG] grid has {len(grid)} rows\")\n                if len(grid) &gt; 0:\n                    print(\n                        f\"[DEBUG] first row type: {type(grid[0])}, length: {len(grid[0])}\"\n                    )\n                    print(f\"[DEBUG] first cell sample: {repr(grid[0][0])}\")\n                else:\n                    print(\"[DEBUG] grid is an empty list\")\n            else:\n                print(\"[DEBUG] grid is NOT a list\")\n\n        if grid is None:\n            if n_rows is None or n_cols is None:\n                raise ValueError(\"n_rows and n_cols must be provided if grid is None\")\n            self.grid = [\n                [Cell(row=i, col=j, state=State.HIDDEN) for j in range(n_cols)]\n                for i in range(n_rows)\n            ]\n        else:\n            self.grid = []\n            for i, row in enumerate(grid):\n                cell_row = []\n                for j, cell_data in enumerate(row):\n                    if isinstance(cell_data, str):\n                        if cell_data.lower() == \"mine\":\n                            cell = Cell(row=i, col=j, state=State.MINE, is_mine=True)\n                        elif cell_data in [s.value for s in State]:\n                            cell = Cell(row=i, col=j, state=State(cell_data))\n                        else:\n                            cell = Cell(row=i, col=j, state=State.HIDDEN)\n                    elif isinstance(cell_data, Cell):\n                        cell = cell_data\n                    else:\n                        raise ValueError(f\"Invalid cell data: {cell_data}\")\n                    cell_row.append(cell)\n                self.grid.append(cell_row)\n\n        self.n_rows = len(self.grid)\n        self.n_cols = len(self.grid[0]) if self.grid else 0\n\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                cell.row = i\n                cell.col = j\n                cell.neighbors = self.adjacent_cells(i, j)\n\n        if self.n_rows &lt; 0 or self.n_cols &lt; 0:\n            raise ValueError(\"Board dimensions must be non-negative integers.\")\n\n        for row in self.grid:\n            for cell in row:\n                if cell.row &lt; 0 or cell.col &lt; 0:\n                    raise ValueError(\"Cell coordinates must be non-negative.\")\n        self.custom_neighbors: dict[tuple[int, int], list[tuple[int, int]]] | None = (\n            None  # Logical neighbor map\n        )\n        self.last_safe_reveal: tuple[int, int] | None = (\n            None  # Track the last safe cell revealed\n        )\n\n        for row in self.grid:\n            for cell in row:\n                cell.neighbors = self.adjacent_cells(cell.row, cell.col)\n\n        self.log_file = \"board_state_log.jsonl\"\n        self.false_hypotheses_remaining: int = (\n            0  # Tracks the number of false hypotheses remaining on the board\n        )\n        self.mines_remaining: int = (\n            0  # Tracks the number of mines remaining on the board\n        )\n\n        # Debugging: Print the initialized grid state\n        if DEBUG:\n            print(\"[DEBUG] Board initialized with grid:\")\n            for row in self.grid:\n                print(\" \".join(cell.state.name for cell in row))\n            print(\n                f\"[BOARD INIT] Created Board with {self.n_rows} rows and {self.n_cols} cols\"\n            )\n            print(f\"[BOARD INIT] Board id={id(self)}, grid id={id(self.grid)}\")\n\n    @staticmethod\n    def from_grid(grid):\n        \"\"\"Construct a Board from a grid of Cell objects.\"\"\"\n        n_rows = len(grid)\n        n_cols = len(grid[0]) if n_rows &gt; 0 else 0\n        board = Board(n_rows, n_cols)\n        board.grid = grid\n        return board\n\n    @property\n    def cells(self) -&gt; list[Cell]:\n        return [c for row in self.grid for c in row]\n\n    def neighbors(self, r, c):\n        if self.custom_neighbors is not None:\n            return [\n                self.grid[nr][nc] for (nr, nc) in self.custom_neighbors.get((r, c), [])\n            ]\n        # Default to physical adjacency\n        nbrs = []\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 &lt;= nr &lt; self.n_rows and 0 &lt;= nc &lt; self.n_cols:\n                    nbrs.append(self.grid[nr][nc])\n        return nbrs\n\n    def reveal(\n        self, row: int | tuple[int, int], col: Optional[int] = None, flood: bool = False\n    ) -&gt; None:\n        if col is None and isinstance(row, tuple):\n            row, col = row\n        cell = self.grid[row][col]\n        if cell.state == State.HIDDEN:\n            cell.state = State.REVEALED\n            self.last_safe_reveal = (row, col)  # Update the last safe reveal position\n            if flood and cell.adjacent_mines == 0:\n                for neighbor in self.neighbors(row, col):\n                    self.reveal(neighbor.row, neighbor.col, flood=True)\n\n    def flag(self, row: int | tuple[int, int], col: Optional[int] = None) -&gt; None:\n        if col is None and isinstance(row, tuple):\n            row, col = row\n        cell = self.grid[row][col]\n        if cell.state == State.HIDDEN:\n            cell.state = State.FLAGGED\n\n    @staticmethod\n    def _from_token(token: str) -&gt; Cell:\n        if token == \"hidden\":\n            return Cell(state=State.HIDDEN)\n        elif token == \"mine\":\n            return Cell(is_mine=True)\n        return Cell()\n\n    def add_cell(self, row, col, is_mine=False):\n        \"\"\"\n        Add a cell to the board at the specified position, dynamically resizing if needed.\n\n        :param row: Row index of the cell.\n        :param col: Column index of the cell.\n        :param is_mine: Whether the cell is a mine.\n        \"\"\"\n        # Expand rows if necessary\n        while row &gt;= self.n_rows:\n            self.grid.append(\n                [\n                    Cell(row=len(self.grid), col=c, state=State.HIDDEN)\n                    for c in range(self.n_cols)\n                ]\n            )\n            self.n_rows += 1\n\n        # Expand columns if necessary\n        for r in range(self.n_rows):\n            while col &gt;= self.n_cols:\n                self.grid[r].append(\n                    Cell(row=r, col=len(self.grid[r]), state=State.HIDDEN)\n                )\n            self.n_cols = max(self.n_cols, col + 1)\n\n        # Add the new cell\n        self.grid[row][col] = Cell(row=row, col=col, is_mine=is_mine)\n\n    def get_neighbors(self, cell):\n        \"\"\"Get neighboring cells for a given cell.\"\"\"\n        neighbors = []\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                r, c = cell.row + dr, cell.col + dc\n                if 0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols:\n                    neighbors.append(self.grid[r][c])\n    return neighbors\n\n    def solve_next(self):\n        \"\"\"Solve the next move on the board.\"\"\"\n        for row in self.grid:\n            for cell in row:\n                if not cell.is_mine and cell.state == State.HIDDEN:\n                    cell.state = State.REVEALED\n                    return cell.row, cell.col\n        raise RuntimeError(\"No moves left to solve.\")\n\n    def hidden_cells(self) -&gt; list[Cell]:\n        \"\"\"Return a list of all hidden Cell objects.\"\"\"\n        hidden_cells = []\n        for r, row in enumerate(self.grid):\n            for c, cell in enumerate(row):\n                if cell.state and cell.state.value == State.HIDDEN.value:\n                    hidden_cells.append(cell)\n        return hidden_cells\n\n    @property\n    def mines_remaining(self) -&gt; int:\n        \"\"\"Return the number of mines remaining on the board.\"\"\"\n        total_mines = sum(cell.is_mine for row in self.grid for cell in row)\n        flagged_mines = sum(\n            cell.state == State.FLAGGED for row in self.grid for cell in row\n        )\n        return total_mines - flagged_mines\n\n    @mines_remaining.setter\n    def mines_remaining(self, value: int) -&gt; None:\n        if value &lt; 0:\n            raise ValueError(\"Mines remaining cannot be negative.\")\n        self._mines_remaining = value\n\n    def adjacent_cells(self, row: int, col: int) -&gt; list[tuple[int, int]]:\n        \"\"\"Return a list of coordinates for all adjacent cells.\"\"\"\n        neighbors = []\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                r, c = row + dr, col + dc\n                if 0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols:\n                    neighbors.append((r, c))\n        return neighbors\n\n    def is_flagged(self, r: int | Cell, c: int | None = None) -&gt; bool:\n        \"\"\"Check if a cell is flagged.\"\"\"\n        if isinstance(r, Cell):\n            return r.state is State.FLAGGED\n        return self.grid[r][c].state is State.FLAGGED\n\n    def is_hidden(self, r: int | Cell, c: int | None = None) -&gt; bool:\n        \"\"\"Check if a cell is hidden.\"\"\"\n        if isinstance(r, Cell):\n            return r.state is State.HIDDEN\n        return self.grid[r][c].state is State.HIDDEN\n\n    def flag(self, r: int | Cell, c: int | None = None) -&gt; None:\n        \"\"\"Flag a cell as a mine.\"\"\"\n        if isinstance(r, Cell):\n            r.state = State.FLAGGED\n        else:\n            self.grid[r][c].state = State.FLAGGED\n\n    def revealed_cells(self):\n        \"\"\"Return all revealed cells.\"\"\"\n        return [\n            cell for row in self.grid for cell in row if cell.state == State.REVEALED\n        ]\n\n    def print_board(self):\n        \"\"\"Print the board for debugging purposes.\"\"\"\n        for row in self.grid:\n            print(\"\".join(str(cell) for cell in row))\n\n    def clue(self, cell) -&gt; int:\n        \"\"\"Return the clue value for a given cell.\"\"\"\n        return cell.clue\n\n    def log_state(self, hypothesis_id, action, confidence):\n        \"\"\"Log the current board state to a .jsonl file with session-scoped rotation.\"\"\"\n        session_id = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        log_file = f\"observer_state_log_{session_id}.jsonl\"\n        log_entry = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"hypothesis_id\": hypothesis_id,\n            \"action\": action,  # e.g., 'flagged' or 'clicked'\n            \"confidence\": confidence,\n            \"belief_state\": [\n                {\n                    \"row\": cell.row,\n                    \"col\": cell.col,\n                    \"state\": cell.state.name,\n                    \"flagged\": cell.state == State.FLAGGED,\n                }\n                for row in self.grid\n                for cell in row\n            ],\n        }\n        with open(log_file, \"a\") as log:\n            log.write(json.dumps(log_entry) + \"\\n\")\n\n    def has_unresolved_cells(self) -&gt; bool:\n        \"\"\"\n        Check if there are any hidden cells remaining on the board.\n\n        Returns:\n            bool: True if there are hidden cells, False otherwise.\n        \"\"\"\n        for row in self.grid:\n            for cell in row:\n                if cell.state == State.HIDDEN:\n                    return True\n        return False\n\n    def __getitem__(self, pos: tuple[int, int]) -&gt; Cell:\n        \"\"\"\n        Allow grid-style access to the board.\n\n        Args:\n            pos (tuple[int, int]): A tuple containing row and column indices.\n\n        Returns:\n            Cell: The cell at the specified position.\n        \"\"\"\n        r, c = pos\n        if not (0 &lt;= r &lt; len(self.grid) and 0 &lt;= c &lt; len(self.grid[0])):\n            raise IndexError(\"Board access out of bounds.\")\n        return self.grid[r][c]\n\n    def __repr__(self):\n        return f\"Board(rows={self.n_rows}, cols={self.n_cols})\"\n\n    def get_revealed_hypotheses(self):\n        \"\"\"Returns a list of revealed hypotheses on the board.\"\"\"\n        return []\n\n    def ensure_row_attribute(self):\n        \"\"\"Ensure all cells in the grid have a .row attribute.\"\"\"\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                cell.row = i\n                cell.col = j\n\n    def is_mine(self, cell):\n        \"\"\"Check if a cell is a mine.\"\"\"\n        return cell.is_mine\n\n    def is_valid(self):\n        \"\"\"\n        Check if the board is in a valid state by verifying clue consistency.\n\n        :return: True if the board is valid, False otherwise.\n        \"\"\"\n        for row in self.grid:\n            for cell in row:\n                if cell.state == State.REVEALED and cell.clue is not None:\n                    # Count neighboring mines\n                    neighbors = self.get_neighbors(cell)\n                    mine_count = sum(1 for neighbor in neighbors if neighbor.is_mine)\n                    if mine_count != cell.clue:\n                        return False\n        return True\n\n    def is_solved(self):\n        \"\"\"Check if the board is solved.\"\"\"\n        return all(\n            cell.is_mine or cell.state == State.REVEALED\n            for row in self.grid\n            for cell in row\n        )\n\n    def export_state(self) -&gt; list[dict]:\n        \"\"\"\n        Export the current board state as a list of dictionaries.\n\n        :return: A list of dictionaries with cell details.\n        \"\"\"\n        return [\n            {\n                \"row\": cell.row,\n                \"col\": cell.col,\n                \"state\": cell.state.name,\n                \"clue\": cell.clue,\n                \"risk\": getattr(cell, \"risk\", None),\n            }\n            for row in self.grid\n            for cell in row\n        ]\n\n    def get_current_confidence(self) -&gt; float:\n        \"\"\"\n        Get the current confidence level.\n\n        :return: The mean confidence level.\n        \"\"\"\n        return BetaConfidence.mean()\n\n    def is_hidden(self, cell_or_coords) -&gt; bool:\n        \"\"\"\n        Check if a cell is hidden.\n\n        :param cell_or_coords: A Cell object or (row, col) tuple.\n        :return: True if the cell is hidden, False otherwise.\n        \"\"\"\n        if isinstance(cell_or_coords, Cell):\n            return cell_or_coords.state == State.HIDDEN\n        row, col = cell_or_coords\n        return self.grid[row][col].state == State.HIDDEN\n\n    def is_flagged(self, cell_or_coords) -&gt; bool:\n        \"\"\"\n        Check if a cell is flagged.\n\n        :param cell_or_coords: A Cell object or (row, col) tuple.\n        :return: True if the cell is flagged, False otherwise.\n        \"\"\"\n        if isinstance(cell_or_coords, Cell):\n            return cell_or_coords.state == State.FLAGGED\n        row, col = cell_or_coords\n        return self.grid[row][col].state == State.FLAGGED\n\n    def flag(self, cell_or_coords) -&gt; None:\n        \"\"\"\n        Flag a cell.\n\n        :param cell_or_coords: A Cell object or (row, col) tuple.\n        \"\"\"\n        if isinstance(cell_or_coords, Cell):\n            cell_or_coords.state = State.FLAGGED\n        else:\n            row, col = cell_or_coords\n            self.grid[row][col].state = State.FLAGGED\n\n    def expand_grid(self, new_rows: int, new_cols: int) -&gt; None:\n        \"\"\"\n        Expands the board grid to the specified dimensions.\n\n        :param new_rows: The new number of rows.\n        :param new_cols: The new number of columns.\n        \"\"\"\n        if new_rows &lt; self.n_rows or new_cols &lt; self.n_cols:\n            raise ValueError(\"New dimensions must be greater than or equal to current dimensions.\")\n\n        # Add new rows if necessary\n        for i in range(self.n_rows, new_rows):\n            new_row = [Cell(row=i, col=j, state=State.HIDDEN) for j in range(new_cols)]\n            self.grid.append(new_row)\n\n        # Expand existing rows to the new column count\n        for i, row in enumerate(self.grid):\n            for j in range(len(row), new_cols):\n                row.append(Cell(row=i, col=j, state=State.HIDDEN))\n\n        # Update board dimensions\n        self.n_rows = new_rows\n        self.n_cols = new_cols\n\n        # Update neighbors for all cells\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                cell.neighbors = self.adjacent_cells(i, j)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.mines_remaining","title":"<code>mines_remaining</code>  <code>property</code> <code>writable</code>","text":"<p>Return the number of mines remaining on the board.</p>"},{"location":"api/#src.ai_minesweeper.Board.__getitem__","title":"<code>__getitem__(pos)</code>","text":"<p>Allow grid-style access to the board.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int]</code> <p>A tuple containing row and column indices.</p> required <p>Returns:</p> Name Type Description <code>Cell</code> <code>Cell</code> <p>The cell at the specified position.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def __getitem__(self, pos: tuple[int, int]) -&gt; Cell:\n    \"\"\"\n    Allow grid-style access to the board.\n\n    Args:\n        pos (tuple[int, int]): A tuple containing row and column indices.\n\n    Returns:\n        Cell: The cell at the specified position.\n    \"\"\"\n    r, c = pos\n    if not (0 &lt;= r &lt; len(self.grid) and 0 &lt;= c &lt; len(self.grid[0])):\n        raise IndexError(\"Board access out of bounds.\")\n    return self.grid[r][c]\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.add_cell","title":"<code>add_cell(row, col, is_mine=False)</code>","text":"<p>Add a cell to the board at the specified position, dynamically resizing if needed.</p> <p>:param row: Row index of the cell. :param col: Column index of the cell. :param is_mine: Whether the cell is a mine.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def add_cell(self, row, col, is_mine=False):\n    \"\"\"\n    Add a cell to the board at the specified position, dynamically resizing if needed.\n\n    :param row: Row index of the cell.\n    :param col: Column index of the cell.\n    :param is_mine: Whether the cell is a mine.\n    \"\"\"\n    # Expand rows if necessary\n    while row &gt;= self.n_rows:\n        self.grid.append(\n            [\n                Cell(row=len(self.grid), col=c, state=State.HIDDEN)\n                for c in range(self.n_cols)\n            ]\n        )\n        self.n_rows += 1\n\n    # Expand columns if necessary\n    for r in range(self.n_rows):\n        while col &gt;= self.n_cols:\n            self.grid[r].append(\n                Cell(row=r, col=len(self.grid[r]), state=State.HIDDEN)\n            )\n        self.n_cols = max(self.n_cols, col + 1)\n\n        # Add the new cell\n        self.grid[row][col] = Cell(row=row, col=col, is_mine=is_mine)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.adjacent_cells","title":"<code>adjacent_cells(row, col)</code>","text":"<p>Return a list of coordinates for all adjacent cells.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def adjacent_cells(self, row: int, col: int) -&gt; list[tuple[int, int]]:\n    \"\"\"Return a list of coordinates for all adjacent cells.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            r, c = row + dr, col + dc\n            if 0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols:\n                neighbors.append((r, c))\n    return neighbors\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.clue","title":"<code>clue(cell)</code>","text":"<p>Return the clue value for a given cell.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def clue(self, cell) -&gt; int:\n    \"\"\"Return the clue value for a given cell.\"\"\"\n    return cell.clue\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.ensure_row_attribute","title":"<code>ensure_row_attribute()</code>","text":"<p>Ensure all cells in the grid have a .row attribute.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def ensure_row_attribute(self):\n    \"\"\"Ensure all cells in the grid have a .row attribute.\"\"\"\n    for i, row in enumerate(self.grid):\n        for j, cell in enumerate(row):\n            cell.row = i\n            cell.col = j\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.expand_grid","title":"<code>expand_grid(new_rows, new_cols)</code>","text":"<p>Expands the board grid to the specified dimensions.</p> <p>:param new_rows: The new number of rows. :param new_cols: The new number of columns.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def expand_grid(self, new_rows: int, new_cols: int) -&gt; None:\n    \"\"\"\n    Expands the board grid to the specified dimensions.\n\n    :param new_rows: The new number of rows.\n    :param new_cols: The new number of columns.\n    \"\"\"\n    if new_rows &lt; self.n_rows or new_cols &lt; self.n_cols:\n        raise ValueError(\"New dimensions must be greater than or equal to current dimensions.\")\n\n    # Add new rows if necessary\n    for i in range(self.n_rows, new_rows):\n        new_row = [Cell(row=i, col=j, state=State.HIDDEN) for j in range(new_cols)]\n        self.grid.append(new_row)\n\n    # Expand existing rows to the new column count\n    for i, row in enumerate(self.grid):\n        for j in range(len(row), new_cols):\n            row.append(Cell(row=i, col=j, state=State.HIDDEN))\n\n    # Update board dimensions\n    self.n_rows = new_rows\n    self.n_cols = new_cols\n\n    # Update neighbors for all cells\n    for i, row in enumerate(self.grid):\n        for j, cell in enumerate(row):\n            cell.neighbors = self.adjacent_cells(i, j)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.export_state","title":"<code>export_state()</code>","text":"<p>Export the current board state as a list of dictionaries.</p> <p>:return: A list of dictionaries with cell details.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def export_state(self) -&gt; list[dict]:\n    \"\"\"\n    Export the current board state as a list of dictionaries.\n\n    :return: A list of dictionaries with cell details.\n    \"\"\"\n    return [\n        {\n            \"row\": cell.row,\n            \"col\": cell.col,\n            \"state\": cell.state.name,\n            \"clue\": cell.clue,\n            \"risk\": getattr(cell, \"risk\", None),\n        }\n        for row in self.grid\n        for cell in row\n    ]\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.flag","title":"<code>flag(cell_or_coords)</code>","text":"<p>Flag a cell.</p> <p>:param cell_or_coords: A Cell object or (row, col) tuple.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def flag(self, cell_or_coords) -&gt; None:\n    \"\"\"\n    Flag a cell.\n\n    :param cell_or_coords: A Cell object or (row, col) tuple.\n    \"\"\"\n    if isinstance(cell_or_coords, Cell):\n        cell_or_coords.state = State.FLAGGED\n    else:\n        row, col = cell_or_coords\n        self.grid[row][col].state = State.FLAGGED\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.from_grid","title":"<code>from_grid(grid)</code>  <code>staticmethod</code>","text":"<p>Construct a Board from a grid of Cell objects.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>@staticmethod\ndef from_grid(grid):\n    \"\"\"Construct a Board from a grid of Cell objects.\"\"\"\n    n_rows = len(grid)\n    n_cols = len(grid[0]) if n_rows &gt; 0 else 0\n    board = Board(n_rows, n_cols)\n    board.grid = grid\n    return board\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.get_current_confidence","title":"<code>get_current_confidence()</code>","text":"<p>Get the current confidence level.</p> <p>:return: The mean confidence level.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def get_current_confidence(self) -&gt; float:\n    \"\"\"\n    Get the current confidence level.\n\n    :return: The mean confidence level.\n    \"\"\"\n    return BetaConfidence.mean()\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.get_neighbors","title":"<code>get_neighbors(cell)</code>","text":"<p>Get neighboring cells for a given cell.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def get_neighbors(self, cell):\n    \"\"\"Get neighboring cells for a given cell.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            r, c = cell.row + dr, cell.col + dc\n            if 0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols:\n                neighbors.append(self.grid[r][c])\n    return neighbors\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.get_revealed_hypotheses","title":"<code>get_revealed_hypotheses()</code>","text":"<p>Returns a list of revealed hypotheses on the board.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def get_revealed_hypotheses(self):\n    \"\"\"Returns a list of revealed hypotheses on the board.\"\"\"\n    return []\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.has_unresolved_cells","title":"<code>has_unresolved_cells()</code>","text":"<p>Check if there are any hidden cells remaining on the board.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if there are hidden cells, False otherwise.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def has_unresolved_cells(self) -&gt; bool:\n    \"\"\"\n    Check if there are any hidden cells remaining on the board.\n\n    Returns:\n        bool: True if there are hidden cells, False otherwise.\n    \"\"\"\n    for row in self.grid:\n        for cell in row:\n            if cell.state == State.HIDDEN:\n                return True\n    return False\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.hidden_cells","title":"<code>hidden_cells()</code>","text":"<p>Return a list of all hidden Cell objects.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def hidden_cells(self) -&gt; list[Cell]:\n    \"\"\"Return a list of all hidden Cell objects.\"\"\"\n    hidden_cells = []\n    for r, row in enumerate(self.grid):\n        for c, cell in enumerate(row):\n            if cell.state and cell.state.value == State.HIDDEN.value:\n                hidden_cells.append(cell)\n    return hidden_cells\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.is_flagged","title":"<code>is_flagged(cell_or_coords)</code>","text":"<p>Check if a cell is flagged.</p> <p>:param cell_or_coords: A Cell object or (row, col) tuple. :return: True if the cell is flagged, False otherwise.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def is_flagged(self, cell_or_coords) -&gt; bool:\n    \"\"\"\n    Check if a cell is flagged.\n\n    :param cell_or_coords: A Cell object or (row, col) tuple.\n    :return: True if the cell is flagged, False otherwise.\n    \"\"\"\n    if isinstance(cell_or_coords, Cell):\n        return cell_or_coords.state == State.FLAGGED\n    row, col = cell_or_coords\n    return self.grid[row][col].state == State.FLAGGED\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.is_hidden","title":"<code>is_hidden(cell_or_coords)</code>","text":"<p>Check if a cell is hidden.</p> <p>:param cell_or_coords: A Cell object or (row, col) tuple. :return: True if the cell is hidden, False otherwise.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def is_hidden(self, cell_or_coords) -&gt; bool:\n    \"\"\"\n    Check if a cell is hidden.\n\n    :param cell_or_coords: A Cell object or (row, col) tuple.\n    :return: True if the cell is hidden, False otherwise.\n    \"\"\"\n    if isinstance(cell_or_coords, Cell):\n        return cell_or_coords.state == State.HIDDEN\n    row, col = cell_or_coords\n    return self.grid[row][col].state == State.HIDDEN\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.is_mine","title":"<code>is_mine(cell)</code>","text":"<p>Check if a cell is a mine.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def is_mine(self, cell):\n    \"\"\"Check if a cell is a mine.\"\"\"\n    return cell.is_mine\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.is_solved","title":"<code>is_solved()</code>","text":"<p>Check if the board is solved.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def is_solved(self):\n    \"\"\"Check if the board is solved.\"\"\"\n    return all(\n        cell.is_mine or cell.state == State.REVEALED\n        for row in self.grid\n        for cell in row\n    )\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.is_valid","title":"<code>is_valid()</code>","text":"<p>Check if the board is in a valid state by verifying clue consistency.</p> <p>:return: True if the board is valid, False otherwise.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def is_valid(self):\n    \"\"\"\n    Check if the board is in a valid state by verifying clue consistency.\n\n    :return: True if the board is valid, False otherwise.\n    \"\"\"\n    for row in self.grid:\n        for cell in row:\n            if cell.state == State.REVEALED and cell.clue is not None:\n                # Count neighboring mines\n                neighbors = self.get_neighbors(cell)\n                mine_count = sum(1 for neighbor in neighbors if neighbor.is_mine)\n                if mine_count != cell.clue:\n                    return False\n    return True\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.log_state","title":"<code>log_state(hypothesis_id, action, confidence)</code>","text":"<p>Log the current board state to a .jsonl file with session-scoped rotation.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def log_state(self, hypothesis_id, action, confidence):\n    \"\"\"Log the current board state to a .jsonl file with session-scoped rotation.\"\"\"\n    session_id = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    log_file = f\"observer_state_log_{session_id}.jsonl\"\n    log_entry = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"hypothesis_id\": hypothesis_id,\n        \"action\": action,  # e.g., 'flagged' or 'clicked'\n        \"confidence\": confidence,\n        \"belief_state\": [\n            {\n                \"row\": cell.row,\n                \"col\": cell.col,\n                \"state\": cell.state.name,\n                \"flagged\": cell.state == State.FLAGGED,\n            }\n            for row in self.grid\n            for cell in row\n        ],\n    }\n    with open(log_file, \"a\") as log:\n        log.write(json.dumps(log_entry) + \"\\n\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.print_board","title":"<code>print_board()</code>","text":"<p>Print the board for debugging purposes.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def print_board(self):\n    \"\"\"Print the board for debugging purposes.\"\"\"\n    for row in self.grid:\n        print(\"\".join(str(cell) for cell in row))\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.revealed_cells","title":"<code>revealed_cells()</code>","text":"<p>Return all revealed cells.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def revealed_cells(self):\n    \"\"\"Return all revealed cells.\"\"\"\n    return [\n        cell for row in self.grid for cell in row if cell.state == State.REVEALED\n    ]\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board.solve_next","title":"<code>solve_next()</code>","text":"<p>Solve the next move on the board.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def solve_next(self):\n    \"\"\"Solve the next move on the board.\"\"\"\n    for row in self.grid:\n        for cell in row:\n            if not cell.is_mine and cell.state == State.HIDDEN:\n                cell.state = State.REVEALED\n                return cell.row, cell.col\n    raise RuntimeError(\"No moves left to solve.\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Cell","title":"<code>Cell</code>  <code>dataclass</code>","text":"Source code in <code>src/ai_minesweeper/cell.py</code> <pre><code>@dataclass\nclass Cell:\n    state: State = State.HIDDEN\n    description: str = \"\"  # Human-readable hypothesis description\n    evidence: str | None = None  # Optional field for supporting data or source\n    adjacent_false_hypotheses: int = 0  # Number of false hypotheses among neighbors\n    is_false_hypothesis: bool = False  # Indicates a false hypothesis (contradiction)\n    is_mine: bool = False  # Indicates if the cell is a mine\n    adjacent_mines: int = 0  # Number of mines among neighbors\n    row: int = -1  # Row position of the cell\n    col: int = -1  # Column position of the cell\n    adjacent_false_hypothesis_weight: float = 0.0  # Weight of adjacent false hypotheses\n    clue: int | None = None  # Numeric clue shown to user\n    z: int | None = None  # Atomic number\n    n: int | None = None  # Neutron number\n    confidence: float = 0.0  # Solver's confidence level for this cell\n    neighbors: Optional[List[\"Cell\"]] = None  # List of neighboring cells\n    symbol: str = \"\"  # Chemical symbol for periodic table cells\n    group: int | None = None  # Group number for periodic table cells\n    period: int | None = None  # Period number for periodic table cells\n\n    def __post_init__(self):\n        pass\n        # print(\n        #     f\"[DEBUG] Cell initialized with state: {self.state}, State id: {id(self.state)}, Expected State.HIDDEN id: {id(State.HIDDEN)}\"\n        # )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the Cell object.\n\n        :return: A string describing the cell's state, false hypothesis status, position, clue, and confidence.\n        \"\"\"\n        return f\"Cell(state={self.state}, is_false_hypothesis={self.is_false_hypothesis}, row={self.row}, col={self.col}, clue={self.clue}, confidence={self.confidence:.2f})\"\n\n    @staticmethod\n    def from_token(token: Union[str, \"Cell\"]) -&gt; \"Cell\":\n        \"\"\"\n        Creates a Cell object from a token.\n\n        :param token: A string or Cell object representing the cell's state.\n        :return: A Cell object initialized based on the token.\n        \"\"\"\n        if isinstance(token, Cell):\n            return token\n        token = str(token).strip().upper()\n        cell = Cell()\n        cell.symbol = token  # Set the symbol attribute for all tokens\n        if token in [\"HIDDEN\", \".\", \"1\"]:\n            cell.state = State.HIDDEN\n        elif token in [\"MINE\", \"*\", \"X\"]:\n            cell.state = State.MINE\n        elif token in [\"FALSE\"] or token.startswith(\"EKA\"):\n            cell.is_false_hypothesis = True\n        elif token.isdigit() and int(token) &gt; 100:\n            cell.is_false_hypothesis = True\n        else:\n            cell.confidence = 0.0  # Default confidence level\n        return cell\n\n    def __hash__(self):\n        \"\"\"\n        Make the Cell class hashable by using its row and column as unique identifiers.\n        \"\"\"\n        return hash((self.row, self.col))\n\n    def __eq__(self, other):\n        \"\"\"\n        Ensure equality comparison is based on row and column.\n        \"\"\"\n        return (\n            isinstance(other, Cell) and self.row == other.row and self.col == other.col\n        )\n\n    def is_hidden(self) -&gt; bool:\n        \"\"\"Check if the cell is in the hidden state.\"\"\"\n        return self.state and getattr(self.state, \"value\", None) == State.HIDDEN.value\n\n    def is_flagged(self) -&gt; bool:\n        return self.state == State.FLAGGED\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Cell.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Ensure equality comparison is based on row and column.</p> Source code in <code>src/ai_minesweeper/cell.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Ensure equality comparison is based on row and column.\n    \"\"\"\n    return (\n        isinstance(other, Cell) and self.row == other.row and self.col == other.col\n    )\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Cell.__hash__","title":"<code>__hash__()</code>","text":"<p>Make the Cell class hashable by using its row and column as unique identifiers.</p> Source code in <code>src/ai_minesweeper/cell.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Make the Cell class hashable by using its row and column as unique identifiers.\n    \"\"\"\n    return hash((self.row, self.col))\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Cell.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the Cell object.</p> <p>:return: A string describing the cell's state, false hypothesis status, position, clue, and confidence.</p> Source code in <code>src/ai_minesweeper/cell.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the Cell object.\n\n    :return: A string describing the cell's state, false hypothesis status, position, clue, and confidence.\n    \"\"\"\n    return f\"Cell(state={self.state}, is_false_hypothesis={self.is_false_hypothesis}, row={self.row}, col={self.col}, clue={self.clue}, confidence={self.confidence:.2f})\"\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Cell.from_token","title":"<code>from_token(token)</code>  <code>staticmethod</code>","text":"<p>Creates a Cell object from a token.</p> <p>:param token: A string or Cell object representing the cell's state. :return: A Cell object initialized based on the token.</p> Source code in <code>src/ai_minesweeper/cell.py</code> <pre><code>@staticmethod\ndef from_token(token: Union[str, \"Cell\"]) -&gt; \"Cell\":\n    \"\"\"\n    Creates a Cell object from a token.\n\n    :param token: A string or Cell object representing the cell's state.\n    :return: A Cell object initialized based on the token.\n    \"\"\"\n    if isinstance(token, Cell):\n        return token\n    token = str(token).strip().upper()\n    cell = Cell()\n    cell.symbol = token  # Set the symbol attribute for all tokens\n    if token in [\"HIDDEN\", \".\", \"1\"]:\n        cell.state = State.HIDDEN\n    elif token in [\"MINE\", \"*\", \"X\"]:\n        cell.state = State.MINE\n    elif token in [\"FALSE\"] or token.startswith(\"EKA\"):\n        cell.is_false_hypothesis = True\n    elif token.isdigit() and int(token) &gt; 100:\n        cell.is_false_hypothesis = True\n    else:\n        cell.confidence = 0.0  # Default confidence level\n    return cell\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Cell.is_hidden","title":"<code>is_hidden()</code>","text":"<p>Check if the cell is in the hidden state.</p> Source code in <code>src/ai_minesweeper/cell.py</code> <pre><code>def is_hidden(self) -&gt; bool:\n    \"\"\"Check if the cell is in the hidden state.\"\"\"\n    return self.state and getattr(self.state, \"value\", None) == State.HIDDEN.value\n</code></pre>"},{"location":"bicycle_validation/","title":"Bicycle Ghost-Rider Validation","text":"<p>Dynamic stabilization in bicycle ghost-rider simulations mirrors controller dimension theory.</p>"},{"location":"bicycle_validation/#key-findings","title":"Key Findings","text":"<ul> <li>Controller dimension principles validated through simulations.</li> <li>Empirical evidence supports theoretical predictions.</li> </ul> <p>For detailed results, refer to the validation report.</p>"},{"location":"ci_setup/","title":"GitHub Actions &amp; Security Setup","text":"Secret Where to add Scope <code>CODECOV_TOKEN</code> Settings \u2192 Secrets \u2192 Actions repository <ol> <li> <p>Go to Settings \u2192 Actions \u2192 General and set:    \u2022 Workflow permissions \u2192 Read and write permissions \u2714    \u2022 Allow GitHub Actions to create and approve pull requests (optional).</p> </li> <li> <p>If self-hosted runners are used, ensure they have the correct labels and are online.</p> </li> </ol> <p>Workflows will fail fast with a clear error if <code>CODECOV_TOKEN</code> is absent.</p>"},{"location":"citation_map/","title":"Citation Map","text":"Code Folder TORUS Supplement Section <code>src/ai_minesweeper/</code> Sec. 3.3: \u03c7-Cycle Recursion <code>src/ai_minesweeper/meta_cell_confidence/</code> Sec. 4.1: Controller Dimension <code>examples/</code> Sec. 5.2: Empirical Tests <code>docs/</code> Sec. 6.1: Theory Overview"},{"location":"confidence_osc/","title":"Confidence Oscillation","text":"<p>Visualize the damped \u03c7-wave fit to solver confidence history. The chart below demonstrates the \u03c4 effect, where \u03c4 represents the decay constant of the oscillation, indicating how quickly the confidence stabilizes over time.</p> <p></p> <p>Parameters: - Amplitude: Initial confidence level. - Decay rate (\u03c4): Rate at which confidence stabilizes. - Period: Time between oscillation peaks.</p> <p>The \u03c4 parameter controls how exploratory the confidence policy becomes. Higher \u03c4 spreads probability mass and encourages more exploratory selections.</p> <p>The \u03c4 effect is critical for understanding solver calibration and risk tolerance adjustments in dynamic environments.</p>"},{"location":"contributor_guide/","title":"Contributor Guide","text":""},{"location":"contributor_guide/#extending-torus-brot","title":"Extending TORUS-brot","text":"<ul> <li>Experiment with higher-order fractals or link with external fractal libraries.</li> <li>Explore mini \"satellite\" copies and measure their scaling to compare with Feigenbaum\u2019s delta for \u03c7-cycle.</li> <li>Introduce random variations each iteration to mimic observer effects and analyze fractal boundary deformation.</li> </ul>"},{"location":"contributor_guide/#improving-meta-cell","title":"Improving Meta-Cell","text":"<ul> <li>Implement more sophisticated Bayesian updates or alternative risk strategies.</li> <li>Enhance confidence visualization with historical trends or interactive charts.</li> <li>Optimize solver integration for larger boards or complex domains.</li> </ul>"},{"location":"contributor_guide/#general-contribution-tips","title":"General Contribution Tips","text":"<ul> <li>Follow the modular design principles outlined in the README.</li> <li>Ensure all new features are documented and tested.</li> <li>Run <code>pytest</code> to verify that all tests pass before submitting a pull request.</li> </ul>"},{"location":"design_meta_cell/","title":"Meta-Cell Confidence Module","text":""},{"location":"design_meta_cell/#overview","title":"Overview","text":"<p>The Meta-Cell Confidence Module introduces a feedback loop to dynamically adjust the hypothesis solver's risk tolerance based on its prediction accuracy. Inspired by TORUS Theory's controller dimension, this module ensures the solver maintains a balanced strategy between exploration and exploitation.</p>"},{"location":"design_meta_cell/#rationale","title":"Rationale","text":"<p>The Meta-Cell Confidence Module dynamically adjusts risk tolerance based on solver accuracy. Using a Beta distribution, it tracks success rates and tunes the solver's behavior.</p>"},{"location":"design_meta_cell/#betaconfidence-class","title":"BetaConfidence Class","text":"<p>Tracks solver confidence using a Beta distribution. Updates confidence based on prediction accuracy using the Brier score.</p>"},{"location":"design_meta_cell/#confidencepolicy-class","title":"ConfidencePolicy Class","text":"<p>Wraps the base solver to adjust move selection based on confidence. Implements a risk threshold that varies with confidence level.</p>"},{"location":"design_meta_cell/#visualization","title":"Visualization","text":"<p>Displays confidence in GUI (Streamlit) or CLI mode, providing real-time feedback on solver calibration.</p>"},{"location":"design_meta_cell/#expected-outcomes","title":"Expected Outcomes","text":"<p>Confidence oscillates over time, reflecting the solver's self-correcting mechanism. This aligns with TORUS Theory's \\chi-cycle structure.</p>"},{"location":"design_meta_cell/#usage","title":"Usage","text":"<p>To enable the confidence module, wrap the base solver with ConfidencePolicy and use BetaConfidence for tracking.</p> <p>Wrap your solver with <code>ConfidencePolicy</code>:</p> <pre><code>from ai_minesweeper.meta_cell_confidence.policy_wrapper import ConfidencePolicy\nfrom ai_minesweeper.meta_cell_confidence.confidence import BetaConfidence\n\nconfidence = BetaConfidence()\npolicy = ConfidencePolicy(base_solver=RiskAssessor, confidence=confidence)\nmove = policy.choose_move(board)\n</code></pre> <p>See the <code>confidence_oscillation_demo.ipynb</code> notebook for a practical demonstration.</p>"},{"location":"design_meta_cell/#meta-cell-confidence-design","title":"Meta-Cell Confidence Design","text":""},{"location":"design_meta_cell/#overview_1","title":"Overview","text":"<p>The meta-cell confidence module tracks the accuracy of mine-probability predictions and adjusts the solver's risk threshold dynamically. This is inspired by the TORUS \"controller dimension\" concept, which harmonizes observer-state interactions.</p>"},{"location":"design_meta_cell/#key-concepts","title":"Key Concepts","text":"<ul> <li>Beta Confidence: A Beta distribution is used to model prediction confidence.</li> <li>Confidence Policy: Modulates exploration vs. exploitation based on confidence.</li> <li>\u03c7-Cycle: The confidence oscillation period aligns with the \u03c7-cycle (~14 moves).</li> </ul>"},{"location":"design_meta_cell/#motivation-and-theoretical-inspiration","title":"Motivation and Theoretical Inspiration","text":"<p>TORUS Controller Dimension: In TORUS Theory, when a system evolves through 14 recursive layers (0D through 13D), an exact closure is not achieved without an extra adjustment; there\u2019s a fixed phase gap of 360\u00b0/14 in the cycle. TORUS introduces a controller operator $R_{\\text{control}}$ to address this, which is applied at the end of the 13D layer to perfectly \"stitch\" the cycle closed. This operator doesn\u2019t add new physics; it\u2019s a structural, zero-trace transform that compensates the residual error, aligning the end state with the beginning. </p> <p>In our Minesweeper analogy, after a sequence of moves (an analog of a full recursion cycle), the solver may have accumulated a calibration error \u2014 its internal probability estimates might not align with reality. The BetaConfidence component plays the role of $R_{\\text{control}}$: it updates the solver\u2019s state to account for that error, ensuring the next cycle of moves starts with a corrected perspective. In essence, the meta-cell provides the \u201ctwist\u201d that closes the loop of perception and action for the solver, just as $R_{\\text{control}}$ provides the final twist to close TORUS\u2019s 14-layer loop.</p> <p>Ghost-Loop Bicycle Analogy: A riderless bicycle can balance itself only within a narrow speed range, a long-puzzling fact explained by a hidden feedback: the spinning front wheel and the geometry form a toroidal feedback loop that self-corrects the bike\u2019s lean. TORUS modeling showed that the wheel\u2019s gyroscopic effect and the ground contact act like two coupled tori that resonate and stabilize the bike when conditions are right (closing the loop in a 14-layer toroidal lattice). The \u201cghost rider\u201d (no human input) stays up because the system itself provides a corrective torque via this closed flux loop. </p> <p>Our meta-cell is analogous to this ghost torque loop. The solver by itself (like a classical bike model) has no way to adjust if its predictions are systematically off. By adding the meta-cell, we introduce a feedback torque in the form of dynamic policy adjustments: when the solver\u2019s confidence drops, the meta-cell pushes it to explore new areas (a corrective action); when confidence is high, it allows the solver to coast with minimal risk. This feedback ensures stability in performance in much the same way the toroidal loop stabilizes the bicycle. It\u2019s an emergent, second-order effect not present in the base solver, but crucial for self-stability.</p>"},{"location":"design_meta_cell/#implementation-details","title":"Implementation Details","text":"<p>BetaConfidence \u2013 Calibration Tracker: We maintain a Beta distribution $Beta(\\alpha, \\beta)$ that represents the solver\u2019s belief about its own accuracy. Initially $(\\alpha=1, \\beta=1)$ implies no prior bias. After each move: - If the solver\u2019s prediction for that move was correct (e.g., it expected a safe cell and it was safe, or expected a mine and a mine was there), we update $\\alpha \\leftarrow \\alpha + 1$. - If the prediction was wrong, $\\beta \\leftarrow \\beta + 1$. This update rule is a simplified Bayesian calibration: essentially treating each move as a Bernoulli trial of the solver\u2019s prediction skill. The Beta mean $m = \\frac{\\alpha}{\\alpha+\\beta}$ is the solver\u2019s running accuracy estimate. Notably, if the solver is overconfident (making mistakes because it underestimates uncertainties), $m$ will drop below 0.5, which serves as an internal alert that the inference engine is miscalibrated.</p> <p>Over many moves, $\\alpha$ and $\\beta$ grow, and the confidence metric becomes more stable. A well-tuned solver will see $\\alpha$ increase faster than $\\beta$, pushing $m$ toward 1 (but never reaching it if occasional surprises occur). An erratic solver will have $m$ hover low, prompting persistent exploration.</p> <p>ConfidencePolicy \u2013 Dynamic Risk Modulation: The policy uses the BetaConfidence $m$ to set a risk threshold $\\tau$. We define a mapping $\\tau = 0.25 - 0.20 \\cdot m$, which yields $\\tau = 0.25$ when $m = 0$ and $\\tau = 0.05$ when $m = 1$. (Any monotonic function would do; this linear mapping is simple and covers the specified range 5%\u201325%.) Before each move, the solver requests a probability for each unopened cell (the chance that cell hides a mine). The ConfidencePolicy then:</p> <ol> <li>Calculates the current $\\tau$.  </li> <li>Finds all cells with predicted mine probability $p \\le \\tau$. These are \u201csafe enough\u201d to click given the current confidence.  </li> <li>If there is at least one such cell, it chooses the one with the lowest $p$ (maximally safe). If no cell falls below $\\tau$ (meaning the solver is very confident but all moves look dangerous, or the solver is forced to guess), the policy defaults to the least risky cell available (the minimum $p$ overall).</li> </ol> <p>This mechanism ensures a couple of behaviors: - High Confidence (m near 1): $\\tau$ is very low, so the solver will refuse to click anything that isn\u2019t almost certain to be safe. It will only proceed if it finds an extremely low-probability cell. In practical terms, if the solver is doing well, it becomes very selective, avoiding any move that looks even slightly risky. This greediness maximizes the chance of winning when the solver \u201cbelieves\u201d it\u2019s on the right track. - Low Confidence (m drops): $\\tau$ increases, meaning the solver is willing to click cells that have a higher probability of being mines. This might seem counter-intuitive (why click risky cells?), but it\u2019s a form of exploration. A low confidence implies the solver\u2019s model might be wrong or incomplete, so taking a calculated risk can reveal new information and potentially break it out of a situation where it\u2019s stuck or repeatedly wrong. Essentially, the solver becomes curious and experimentally probes the board when it doubts itself.</p>"},{"location":"design_meta_cell/#confidence-visualization","title":"Confidence Visualization","text":"<p>The confidence level of the solver is dynamically displayed in the Streamlit app. This includes:</p> <ul> <li>Metric Display: Shows the current confidence as a percentage.</li> <li>Progress Bar: Provides a visual representation of the confidence level.</li> </ul> <p>These elements update in real-time as the solver makes moves and adjusts its confidence based on outcomes. This feature helps users understand the solver's decision-making process and its calibration over time.</p>"},{"location":"design_meta_cell/#module-path-architecture","title":"Module Path Architecture","text":""},{"location":"design_meta_cell/#architectural-note","title":"Architectural Note","text":"<p>The Minesweeper framework now enforces a single import path for its core module (<code>ai_minesweeper</code>). This is by design, reflecting TORUS Theory\u2019s principle of a single observer-state locus. In practice, it means the codebase is accessed through one coherent package namespace, ensuring consistency (no duplicate modules). This change eliminates ambiguity in the code\u2019s \u201cpoint of view,\u201d analogous to maintaining a single frame of reference for all observations in TORUS\u2019s \u03c7-consistent system.</p>"},{"location":"design_meta_cell/#references","title":"References","text":"<ul> <li>TORUS Theory and Bicycle Self-Stability \u00a73, \u00a74</li> <li>Unified Glossary \u2013 entries \"\u03c7-cycle\", \"Controller Dimension\".</li> </ul>"},{"location":"glossary/","title":"Glossary &amp; FAQ","text":""},{"location":"glossary/#glossary","title":"Glossary","text":""},{"location":"glossary/#-cycle","title":"\u03c7-cycle","text":"<p>Recursive patterns in data, such as prime residue distributions or noise patterns.</p>"},{"location":"glossary/#controller-dimension","title":"Controller Dimension","text":"<p>Theory explaining dynamic stabilization in systems.</p>"},{"location":"glossary/#erc","title":"ERC","text":"<p>Empirical Recursive Cycle, a statistical measure of \u03c7-cycle significance.</p> <p>For more terms, refer to the TORUS Theory paper.</p>"},{"location":"glossary/#faq","title":"FAQ","text":""},{"location":"glossary/#what-is-the-significance-of-8-evidence","title":"What is the significance of 8-\u03c3 evidence?","text":"<p>8-\u03c3 corresponds to a 1 in 10\u00b9\u2075 chance of coincidence, indicating extremely high credibility.</p>"},{"location":"glossary/#how-does-the-controller-dimension-apply-to-hypothesis-solvers","title":"How does the controller dimension apply to hypothesis solvers?","text":"<p>It modulates the solver's risk tolerance, balancing exploration and exploitation phases.</p>"},{"location":"glossary/#what-domains-has-torus-theory-been-validated-in","title":"What domains has TORUS Theory been validated in?","text":"<p>Gravitational wave detectors, prime spirals, and dynamic systems like bicycle stabilization.</p>"},{"location":"gw_validation/","title":"Gravitational Wave Validation","text":"<p>Empirical evidence shows 8-\u03c3 significance of \u03c7-cycle patterns in noise data from gravitational wave detectors.</p>"},{"location":"gw_validation/#key-findings","title":"Key Findings","text":"<ul> <li>Recursive \u03c7-cycle patterns detected in detector noise.</li> <li>Validation performed using statistical analysis.</li> </ul> <p>For detailed results, refer to the validation report.</p>"},{"location":"meg_protocol_outline/","title":"IRB-Ready MEG Protocol Outline","text":""},{"location":"meg_protocol_outline/#objective","title":"Objective","text":"<p>Investigate \u03c7-cycle oscillations in neural activity using MEG.</p>"},{"location":"meg_protocol_outline/#participants","title":"Participants","text":"<ul> <li>20 healthy adults aged 18\u201335.</li> <li>Exclusion criteria: neurological disorders, metal implants.</li> </ul>"},{"location":"meg_protocol_outline/#procedure","title":"Procedure","text":"<ol> <li>Baseline recording: 5 minutes of resting-state MEG.</li> <li>Task phase: Participants play Minesweeper with confidence module active.</li> <li>Post-task recording: 5 minutes of resting-state MEG.</li> </ol>"},{"location":"meg_protocol_outline/#analysis","title":"Analysis","text":"<ul> <li>Time-frequency analysis to detect \u03c7-cycle oscillations (~14 moves).</li> <li>Correlation with confidence scores from the module.</li> </ul>"},{"location":"meg_protocol_outline/#ethical-considerations","title":"Ethical Considerations","text":"<ul> <li>Informed consent.</li> <li>Data anonymization.</li> <li>Compliance with IRB guidelines.</li> </ul>"},{"location":"meta_cell_usage/","title":"Meta-Cell Guide","text":"<p>Learn how to use the Meta-Cell Confidence Module to enhance solver stability.</p>"},{"location":"meta_cell_usage/#features","title":"Features","text":"<ul> <li>Adaptive risk tolerance.</li> <li>Real-time confidence visualization.</li> </ul>"},{"location":"meta_cell_usage/#usage","title":"Usage","text":"<p>Enable the Meta-Cell module in the Streamlit sidebar.</p>"},{"location":"prime_residue/","title":"Prime Residue Analysis","text":"<p>The S-statistic measures variance-to-mean ratio of prime residues modulo 14.</p> Residue Count 0 ... 1 ... ... ... <p>S-statistic: ...</p>"},{"location":"prime_spirals/","title":"Prime Spirals Validation","text":"<p>Prime residue distributions exhibit recursive \u03c7-cycle patterns, matching theoretical predictions.</p>"},{"location":"prime_spirals/#key-findings","title":"Key Findings","text":"<ul> <li>Mod-14 prime spirals demonstrate \u03c7-cycle recursion.</li> <li>Validation performed using computational simulations.</li> </ul> <p>For detailed results, refer to the validation report.</p>"},{"location":"roadmap_overview/","title":"Roadmap Overview","text":""},{"location":"roadmap_overview/#theory","title":"Theory","text":"<p>TORUS Theory introduces recursive self-correction mechanisms in complex systems, leveraging the \u03c7-cycle and controller dimension to stabilize oscillatory behavior.</p>"},{"location":"roadmap_overview/#simulation","title":"Simulation","text":"<p>Simulations validate \u03c7-cycle predictions across domains: - Gravitational wave noise patterns. - Prime residue spirals. - Dynamic systems like bicycle stabilization.</p>"},{"location":"roadmap_overview/#empirical-tests","title":"Empirical Tests","text":"<p>Empirical validations demonstrate 8-\u03c3 evidence: - Gravitational wave detectors: \u03c7-cycle in noise patterns. - Prime spirals: Recursive residue patterns. - Bicycle ghost-rider: Controller dimension stabilization.</p>"},{"location":"roadmap_overview/#open-falsifiers","title":"Open Falsifiers","text":"<p>Future work includes: - Extending \u03c7-cycle predictions to new domains. - Testing controller dimension in protein-folding dynamics. - Exploring legal precedent graphs for recursive patterns.</p>"},{"location":"torus_brot_demo/","title":"TORUS-brot Fractal Demo","text":"<p>Explore the 14-fold \u03c7-recursive fractal generated by the TORUS-brot algorithm.</p> <p></p> <p>This image represents the \u03c7-recursive observer-state projection, demonstrating fractal alignment in Minesweeper theory.</p>"},{"location":"web_demo/","title":"Web Demo \u2013 TBD","text":""},{"location":"why_torus_matters/","title":"Why TORUS Matters","text":"<p>The \u03c7-cycle and controller dimension principles are central to the Minesweeper Discovery Framework (MDF). These concepts enable hypothesis discovery by transforming complex domains into Minesweeper-style puzzles.</p>"},{"location":"why_torus_matters/#-cycle","title":"\u03c7-cycle","text":"<p>The \u03c7-cycle represents recursive patterns in data, such as prime residue distributions or noise patterns in gravitational wave detectors.</p>"},{"location":"why_torus_matters/#controller-dimension","title":"Controller Dimension","text":"<p>Controller dimension theory explains dynamic stabilization in systems, such as bicycle ghost-rider simulations.</p> <p>For more details, refer to the TORUS Theory paper.</p>"},{"location":"tutorials/discovering_phi_phase_reset/","title":"Discovering \u03c6-Phase Reset","text":"<p>This tutorial explains how to use the Phase-Lock Minesweeper module to detect \u03c6-phase resets in time-series data.</p>"},{"location":"tutorials/discovering_phi_phase_reset/#steps","title":"Steps","text":"<ol> <li>Configure the sampling rate and target frequency in <code>phase_lock_phi_config.yaml</code>.</li> <li>Use the <code>evaluate_cell</code> function to extract 14-cycle segments.</li> <li>Apply the Hilbert transform and compute \u0394\u03c6.</li> <li>Run the Rayleigh test to check for resets.</li> </ol>"},{"location":"tutorials/discovering_phi_phase_reset/#example","title":"Example","text":"<p>Refer to the notebook <code>PhaseLockMinesweeper.ipynb</code> for a demonstration.</p>"},{"location":"tutorials/element_discovery/","title":"Element Discovery Tutorial","text":""},{"location":"tutorials/element_discovery/#overview","title":"Overview","text":"<p>This tutorial demonstrates how the AI Minesweeper Discovery Framework can be applied to uncover missing elements in the periodic table. The periodic table is represented as a grid, where each cell corresponds to an element. Discovered elements are marked as safe, while undiscovered elements are treated as mines.</p>"},{"location":"tutorials/element_discovery/#dataset","title":"Dataset","text":"<p>The dataset used for this demo is <code>examples/boards/elements.csv</code>. It includes: - atomic_number: The atomic number of the element. - symbol: The chemical symbol. - group: The group number in the periodic table. - period: The period number in the periodic table. - is_discovered: A boolean indicating whether the element is discovered.</p>"},{"location":"tutorials/element_discovery/#rules","title":"Rules","text":"<ul> <li>A revealed cell provides a clue indicating the number of undiscovered elements adjacent to it.</li> <li>Adjacent relationships are based on the periodic table layout (groups and periods).</li> </ul>"},{"location":"tutorials/element_discovery/#steps","title":"Steps","text":"<ol> <li>Launch the Streamlit app:    <code>bash    streamlit run streamlit_app.py</code></li> <li>Select \"Periodic Table (Element Discovery)\" from the domain menu.</li> <li>Observe the periodic table grid and interact with the solver to reveal clues and identify undiscovered elements.</li> </ol>"},{"location":"tutorials/element_discovery/#example","title":"Example","text":"<p>Revealing Oxygen (O) might show a clue \"1\", indicating one of its adjacent cells contains an undiscovered element.</p>"},{"location":"tutorials/element_discovery/#notes","title":"Notes","text":"<p>This demo is a simplified representation of the periodic table and is intended for educational purposes.</p>"},{"location":"tutorials/prime_residue_recursion/","title":"Prime Residue Recursion","text":"<p>This tutorial explains how to use the Prime Residue Minesweeper module to analyze prime spirals.</p>"},{"location":"tutorials/prime_residue_recursion/#steps","title":"Steps","text":"<ol> <li>Configure the prime window and \u03c6 constant in <code>primes_chi_config.yaml</code>.</li> <li>Use the <code>build_board</code> function to create a board.</li> <li>Evaluate cells using <code>evaluate_cell</code>.</li> <li>Compute the ridge score using <code>compute_ridge_score</code>.</li> </ol>"},{"location":"tutorials/prime_residue_recursion/#example","title":"Example","text":"<p>Refer to the notebook <code>PrimeResidueMinesweeper.ipynb</code> for a demonstration.</p>"},{"location":"whitepaper_src/whitepage/","title":"What is AI-Minesweeper?","text":"<p>AI-Minesweeper is a hypothesis discovery framework inspired by the classic game Minesweeper. It uses epistemic reasoning to uncover hidden patterns, contradictions, and gaps in structured datasets. The framework is designed to be domain-agnostic, allowing researchers to plug in custom datasets and adjacency logic.</p>"},{"location":"whitepaper_src/whitepage/#plug-in-design","title":"Plug-in Design","text":"<p>The framework supports modular plug-ins for domain-specific logic. Each plug-in defines adjacency rules, clue generation, and hypothesis evaluation tailored to the dataset.</p>"},{"location":"whitepaper_src/whitepage/#demo-list","title":"Demo List","text":"<ul> <li>TORUS Demo: Explore topological patterns.</li> <li>Cymatics Demo: Analyze wave interference data.</li> <li>Prime-Spiral Demo: Investigate prime number distributions.</li> <li>Periodic Table Demo: Discover gaps and anomalies in the periodic table.</li> </ul>"},{"location":"whitepaper_src/whitepage/#torus-integration","title":"TORUS Integration","text":"<p>TORUS is a complementary tool for topological data analysis. AI-Minesweeper integrates with TORUS to enhance hypothesis discovery in spatial datasets.</p>"},{"location":"whitepaper_src/whitepage/#case-study-2-hunting-super-heavy-elements","title":"Case Study 2 \u2013 Hunting Super-Heavy Elements","text":"<p>The periodic-table domain adapter demonstrates hypothesis discovery in nuclear physics. Weighted clues guide the search for unbound isotopes, treating unstable nuclei as mines. This approach highlights gaps in nuclear stability metrics, enabling predictions for super-heavy elements like Z 119\u2013126.</p>"}}]}

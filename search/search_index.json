{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AI Hypothesis Discovery Framework","text":"<p>The AI Hypothesis Discovery Framework is a comprehensive toolkit designed to facilitate the development and testing of AI algorithms for systematic hypothesis exploration. It provides a robust environment for researchers and enthusiasts to explore various AI techniques and strategies, enabling them to understand and improve the performance of their algorithms in a controlled setting.</p> <p>With a focus on ease of use and extensibility, the framework offers a range of features including customizable hypothesis grids, AI agent integration, and performance analysis tools. Whether you're a seasoned AI researcher or a newcomer to the field, this framework provides the resources you need to delve into the world of AI-driven hypothesis discovery.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the framework, use the following command:</p> <pre><code>pip install ai-hypothesis-discovery-framework\n</code></pre>"},{"location":"#quick-cli-example","title":"Quick CLI Example","text":"<p>Here's a quick example of how to run a hypothesis discovery session with an AI agent using the CLI:</p> <pre><code>ai-hypothesis-discovery --agent=random --grid-size=10 --false-hypotheses=15\n</code></pre> <p>This command runs a hypothesis discovery session on a 10x10 grid with 15 false hypotheses, using a random AI agent.</p>"},{"location":"#hero-panel","title":"Hero Panel","text":"<p>\u03c7 Value: 50-digit \u03c7 = 1.41421356237309504880168872420969807856967187537694</p> <p></p>"},{"location":"#versions","title":"Versions","text":""},{"location":"#changelog","title":"Changelog","text":"v0.4 - Added TORUS-brot fractal module. - Enhanced Meta-Cell Confidence Module.  v0.3 - Initial release with Hypothesis Discovery AI."},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>Discovering \u03c6-Phase Reset</li> <li>Prime Residue Recursion</li> <li>Periodic Table Demo</li> <li>Fractal Demo: Explore the \u03c7-recursive observer-state projection and its implications in Hypothesis Discovery theory.</li> </ul>"},{"location":"#white-paper","title":"White-paper","text":"<ul> <li>What is AI-Hypothesis Discovery?</li> </ul>"},{"location":"LLM_backends/","title":"Configuring LLM Backends","text":"<p>The AI Minesweeper framework supports multiple LLM backends. Follow the instructions below to configure your preferred backend.</p>"},{"location":"LLM_backends/#openai","title":"OpenAI","text":"<ol> <li>Obtain an API key from OpenAI.</li> <li>Paste the key into the environment variable <code>OPENAI_API_KEY</code>.</li> </ol>"},{"location":"LLM_backends/#anthropic-claude","title":"Anthropic Claude","text":"<ol> <li>Obtain an API key from Anthropic.</li> <li>Paste the key into the environment variable <code>CLAUDE_API_KEY</code>.</li> </ol>"},{"location":"LLM_backends/#local-ollama","title":"Local (Ollama)","text":"<ol> <li>Ensure the Ollama server is running locally.</li> <li>No API key is required for this backend.</li> </ol>"},{"location":"LLM_backends/#none","title":"None","text":"<ol> <li>Select 'none' as the backend in the Streamlit UI.</li> <li>This option disables LLM integration.</li> </ol>"},{"location":"api/","title":"Api","text":"<p>AI Minesweeper Discovery Framework</p> <p>A \u03c7-recursive minesweeper AI with TORUS theory integration and meta-cell confidence. Version 1.1.0</p>"},{"location":"api/#src.ai_minesweeper.BetaConfidence","title":"<code>BetaConfidence</code>","text":"<p>Beta confidence tracker for \u03c7-recursive decision making.</p> <p>Implements adaptive confidence measurement and feedback mechanisms aligned with TORUS theory for cyclical learning improvement.</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/beta_confidence.py</code> <pre><code>class BetaConfidence:\n    \"\"\"\n    Beta confidence tracker for \u03c7-recursive decision making.\n\n    Implements adaptive confidence measurement and feedback mechanisms\n    aligned with TORUS theory for cyclical learning improvement.\n    \"\"\"\n\n    def __init__(self, alpha: float = 1.0, beta: float = 1.0):\n        \"\"\"\n        Initialize beta confidence tracker.\n\n        Args:\n            alpha: Success parameter for beta distribution\n            beta: Failure parameter for beta distribution\n        \"\"\"\n        self.alpha = alpha\n        self.beta = beta\n        self.initial_alpha = alpha\n        self.initial_beta = beta\n\n        # Track decision outcomes\n        self.decision_history: List[Tuple[str, bool, float]] = []\n        self.confidence_scores: List[float] = []\n\n        # \u03c7-recursive state\n        self.chi_cycle_phase = 0\n        self.recursive_updates = 0\n\n        self.logger = logging.getLogger(__name__)\n\n    def get_confidence(self) -&gt; float:\n        \"\"\"\n        Get current confidence level based on beta distribution.\n\n        Returns:\n            Confidence value between 0.0 and 1.0\n        \"\"\"\n        # Beta distribution mean: alpha / (alpha + beta)\n        base_confidence = self.alpha / (self.alpha + self.beta)\n\n        # Apply \u03c7-recursive modulation\n        chi_modulation = self._calculate_chi_modulation()\n\n        # Combine base confidence with \u03c7-recursive feedback\n        final_confidence = base_confidence * chi_modulation\n\n        # Ensure bounds\n        final_confidence = max(0.01, min(0.99, final_confidence))\n\n        self.confidence_scores.append(final_confidence)\n        return final_confidence\n\n    def update_success(self, decision_type: str, outcome_quality: float = 1.0) -&gt; None:\n        \"\"\"\n        Update confidence based on successful decision.\n\n        Args:\n            decision_type: Type of decision made ('reveal', 'flag', 'deduce')\n            outcome_quality: Quality of outcome (0.0 to 1.0)\n        \"\"\"\n        # Update beta distribution parameters\n        self.alpha += outcome_quality\n\n        # Record decision\n        self.decision_history.append((decision_type, True, outcome_quality))\n\n        # \u03c7-recursive update\n        self._update_chi_recursive_state(True, outcome_quality)\n\n        self.logger.debug(f\"Success update: {decision_type}, quality={outcome_quality:.3f}\")\n\n    def update_failure(self, decision_type: str, failure_severity: float = 1.0) -&gt; None:\n        \"\"\"\n        Update confidence based on failed decision.\n\n        Args:\n            decision_type: Type of decision made\n            failure_severity: Severity of failure (0.0 to 1.0)\n        \"\"\"\n        # Update beta distribution parameters\n        self.beta += failure_severity\n\n        # Record decision\n        self.decision_history.append((decision_type, False, failure_severity))\n\n        # \u03c7-recursive update\n        self._update_chi_recursive_state(False, failure_severity)\n\n        self.logger.debug(f\"Failure update: {decision_type}, severity={failure_severity:.3f}\")\n\n    def _calculate_chi_modulation(self) -&gt; float:\n        \"\"\"\n        Calculate \u03c7-recursive modulation factor.\n\n        Returns:\n            Modulation factor for confidence adjustment\n        \"\"\"\n        if len(self.confidence_scores) &lt; 5:\n            return 1.0\n\n        # Analyze recent confidence trend\n        recent_scores = self.confidence_scores[-5:]\n        trend = np.polyfit(range(len(recent_scores)), recent_scores, 1)[0]\n\n        # \u03c7-cycle phase progression\n        self.chi_cycle_phase = (self.chi_cycle_phase + 1) % 20\n\n        # TORUS theory cyclical modulation\n        torus_factor = 0.9 + 0.2 * np.cos(2 * np.pi * self.chi_cycle_phase / 20)\n\n        # Trend-based adjustment\n        if trend &gt; 0.01:  # Improving trend\n            trend_factor = 1.05\n        elif trend &lt; -0.01:  # Declining trend\n            trend_factor = 0.95\n        else:  # Stable trend\n            trend_factor = 1.0\n\n        return torus_factor * trend_factor\n\n    def _update_chi_recursive_state(self, success: bool, magnitude: float) -&gt; None:\n        \"\"\"\n        Update \u03c7-recursive state based on decision outcome.\n\n        Args:\n            success: Whether the decision was successful\n            magnitude: Magnitude of the outcome\n        \"\"\"\n        self.recursive_updates += 1\n\n        # \u03c7-recursive adaptation based on outcome pattern\n        if len(self.decision_history) &gt;= 3:\n            recent_outcomes = [outcome for _, outcome, _ in self.decision_history[-3:]]\n\n            # Pattern detection for \u03c7-recursive learning\n            if all(recent_outcomes):\n                # Consecutive successes - increase confidence adaptation rate\n                self.alpha *= 1.02\n            elif not any(recent_outcomes):\n                # Consecutive failures - decrease confidence more slowly\n                self.beta *= 0.98\n\n    def get_decision_confidence(self, decision_type: str) -&gt; float:\n        \"\"\"\n        Get confidence level for a specific decision type.\n\n        Args:\n            decision_type: Type of decision ('reveal', 'flag', 'deduce')\n\n        Returns:\n            Confidence level for this decision type\n        \"\"\"\n        base_confidence = self.get_confidence()\n\n        # Type-specific adjustments based on history\n        type_history = [\n            (outcome, quality) for dtype, outcome, quality in self.decision_history\n            if dtype == decision_type\n        ]\n\n        if not type_history:\n            return base_confidence\n\n        # Calculate type-specific success rate\n        successes = sum(quality for outcome, quality in type_history if outcome)\n        attempts = len(type_history)\n        type_success_rate = successes / attempts if attempts &gt; 0 else 0.5\n\n        # Combine base confidence with type-specific rate\n        combined_confidence = (base_confidence + type_success_rate) / 2\n\n        return max(0.01, min(0.99, combined_confidence))\n\n    def reset_confidence(self) -&gt; None:\n        \"\"\"Reset confidence to initial values.\"\"\"\n        self.alpha = self.initial_alpha\n        self.beta = self.initial_beta\n        self.decision_history.clear()\n        self.confidence_scores.clear()\n        self.chi_cycle_phase = 0\n        self.recursive_updates = 0\n\n        self.logger.info(\"Beta confidence reset to initial values\")\n\n    def get_confidence_trend(self, window: int = 10) -&gt; float:\n        \"\"\"\n        Get confidence trend over recent decisions.\n\n        Args:\n            window: Number of recent scores to analyze\n\n        Returns:\n            Trend value (positive = improving, negative = declining)\n        \"\"\"\n        if len(self.confidence_scores) &lt; 2:\n            return 0.0\n\n        recent_scores = self.confidence_scores[-window:]\n        if len(recent_scores) &lt; 2:\n            return 0.0\n\n        # Linear regression slope\n        trend = np.polyfit(range(len(recent_scores)), recent_scores, 1)[0]\n        return trend\n\n    def get_statistics(self) -&gt; Dict:\n        \"\"\"\n        Get statistical summary of confidence tracking.\n\n        Returns:\n            Dictionary with confidence statistics\n        \"\"\"\n        if not self.confidence_scores:\n            return {\"error\": \"No confidence data available\"}\n\n        decision_types = {}\n        for dtype, outcome, quality in self.decision_history:\n            if dtype not in decision_types:\n                decision_types[dtype] = {\"successes\": 0, \"attempts\": 0}\n            decision_types[dtype][\"attempts\"] += 1\n            if outcome:\n                decision_types[dtype][\"successes\"] += quality\n\n        return {\n            \"current_confidence\": self.get_confidence(),\n            \"alpha\": self.alpha,\n            \"beta\": self.beta,\n            \"total_decisions\": len(self.decision_history),\n            \"confidence_trend\": self.get_confidence_trend(),\n            \"chi_cycle_phase\": self.chi_cycle_phase,\n            \"recursive_updates\": self.recursive_updates,\n            \"decision_types\": decision_types,\n            \"mean_confidence\": np.mean(self.confidence_scores),\n            \"confidence_std\": np.std(self.confidence_scores)\n        }\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.beta_confidence.BetaConfidence.__init__","title":"<code>__init__(alpha=1.0, beta=1.0)</code>","text":"<p>Initialize beta confidence tracker.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Success parameter for beta distribution</p> <code>1.0</code> <code>beta</code> <code>float</code> <p>Failure parameter for beta distribution</p> <code>1.0</code> Source code in <code>src/ai_minesweeper/meta_cell_confidence/beta_confidence.py</code> <pre><code>def __init__(self, alpha: float = 1.0, beta: float = 1.0):\n    \"\"\"\n    Initialize beta confidence tracker.\n\n    Args:\n        alpha: Success parameter for beta distribution\n        beta: Failure parameter for beta distribution\n    \"\"\"\n    self.alpha = alpha\n    self.beta = beta\n    self.initial_alpha = alpha\n    self.initial_beta = beta\n\n    # Track decision outcomes\n    self.decision_history: List[Tuple[str, bool, float]] = []\n    self.confidence_scores: List[float] = []\n\n    # \u03c7-recursive state\n    self.chi_cycle_phase = 0\n    self.recursive_updates = 0\n\n    self.logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.beta_confidence.BetaConfidence.get_confidence","title":"<code>get_confidence()</code>","text":"<p>Get current confidence level based on beta distribution.</p> <p>Returns:</p> Type Description <code>float</code> <p>Confidence value between 0.0 and 1.0</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/beta_confidence.py</code> <pre><code>def get_confidence(self) -&gt; float:\n    \"\"\"\n    Get current confidence level based on beta distribution.\n\n    Returns:\n        Confidence value between 0.0 and 1.0\n    \"\"\"\n    # Beta distribution mean: alpha / (alpha + beta)\n    base_confidence = self.alpha / (self.alpha + self.beta)\n\n    # Apply \u03c7-recursive modulation\n    chi_modulation = self._calculate_chi_modulation()\n\n    # Combine base confidence with \u03c7-recursive feedback\n    final_confidence = base_confidence * chi_modulation\n\n    # Ensure bounds\n    final_confidence = max(0.01, min(0.99, final_confidence))\n\n    self.confidence_scores.append(final_confidence)\n    return final_confidence\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.beta_confidence.BetaConfidence.get_confidence_trend","title":"<code>get_confidence_trend(window=10)</code>","text":"<p>Get confidence trend over recent decisions.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>int</code> <p>Number of recent scores to analyze</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Trend value (positive = improving, negative = declining)</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/beta_confidence.py</code> <pre><code>def get_confidence_trend(self, window: int = 10) -&gt; float:\n    \"\"\"\n    Get confidence trend over recent decisions.\n\n    Args:\n        window: Number of recent scores to analyze\n\n    Returns:\n        Trend value (positive = improving, negative = declining)\n    \"\"\"\n    if len(self.confidence_scores) &lt; 2:\n        return 0.0\n\n    recent_scores = self.confidence_scores[-window:]\n    if len(recent_scores) &lt; 2:\n        return 0.0\n\n    # Linear regression slope\n    trend = np.polyfit(range(len(recent_scores)), recent_scores, 1)[0]\n    return trend\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.beta_confidence.BetaConfidence.get_decision_confidence","title":"<code>get_decision_confidence(decision_type)</code>","text":"<p>Get confidence level for a specific decision type.</p> <p>Parameters:</p> Name Type Description Default <code>decision_type</code> <code>str</code> <p>Type of decision ('reveal', 'flag', 'deduce')</p> required <p>Returns:</p> Type Description <code>float</code> <p>Confidence level for this decision type</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/beta_confidence.py</code> <pre><code>def get_decision_confidence(self, decision_type: str) -&gt; float:\n    \"\"\"\n    Get confidence level for a specific decision type.\n\n    Args:\n        decision_type: Type of decision ('reveal', 'flag', 'deduce')\n\n    Returns:\n        Confidence level for this decision type\n    \"\"\"\n    base_confidence = self.get_confidence()\n\n    # Type-specific adjustments based on history\n    type_history = [\n        (outcome, quality) for dtype, outcome, quality in self.decision_history\n        if dtype == decision_type\n    ]\n\n    if not type_history:\n        return base_confidence\n\n    # Calculate type-specific success rate\n    successes = sum(quality for outcome, quality in type_history if outcome)\n    attempts = len(type_history)\n    type_success_rate = successes / attempts if attempts &gt; 0 else 0.5\n\n    # Combine base confidence with type-specific rate\n    combined_confidence = (base_confidence + type_success_rate) / 2\n\n    return max(0.01, min(0.99, combined_confidence))\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.beta_confidence.BetaConfidence.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get statistical summary of confidence tracking.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with confidence statistics</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/beta_confidence.py</code> <pre><code>def get_statistics(self) -&gt; Dict:\n    \"\"\"\n    Get statistical summary of confidence tracking.\n\n    Returns:\n        Dictionary with confidence statistics\n    \"\"\"\n    if not self.confidence_scores:\n        return {\"error\": \"No confidence data available\"}\n\n    decision_types = {}\n    for dtype, outcome, quality in self.decision_history:\n        if dtype not in decision_types:\n            decision_types[dtype] = {\"successes\": 0, \"attempts\": 0}\n        decision_types[dtype][\"attempts\"] += 1\n        if outcome:\n            decision_types[dtype][\"successes\"] += quality\n\n    return {\n        \"current_confidence\": self.get_confidence(),\n        \"alpha\": self.alpha,\n        \"beta\": self.beta,\n        \"total_decisions\": len(self.decision_history),\n        \"confidence_trend\": self.get_confidence_trend(),\n        \"chi_cycle_phase\": self.chi_cycle_phase,\n        \"recursive_updates\": self.recursive_updates,\n        \"decision_types\": decision_types,\n        \"mean_confidence\": np.mean(self.confidence_scores),\n        \"confidence_std\": np.std(self.confidence_scores)\n    }\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.beta_confidence.BetaConfidence.reset_confidence","title":"<code>reset_confidence()</code>","text":"<p>Reset confidence to initial values.</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/beta_confidence.py</code> <pre><code>def reset_confidence(self) -&gt; None:\n    \"\"\"Reset confidence to initial values.\"\"\"\n    self.alpha = self.initial_alpha\n    self.beta = self.initial_beta\n    self.decision_history.clear()\n    self.confidence_scores.clear()\n    self.chi_cycle_phase = 0\n    self.recursive_updates = 0\n\n    self.logger.info(\"Beta confidence reset to initial values\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.beta_confidence.BetaConfidence.update_failure","title":"<code>update_failure(decision_type, failure_severity=1.0)</code>","text":"<p>Update confidence based on failed decision.</p> <p>Parameters:</p> Name Type Description Default <code>decision_type</code> <code>str</code> <p>Type of decision made</p> required <code>failure_severity</code> <code>float</code> <p>Severity of failure (0.0 to 1.0)</p> <code>1.0</code> Source code in <code>src/ai_minesweeper/meta_cell_confidence/beta_confidence.py</code> <pre><code>def update_failure(self, decision_type: str, failure_severity: float = 1.0) -&gt; None:\n    \"\"\"\n    Update confidence based on failed decision.\n\n    Args:\n        decision_type: Type of decision made\n        failure_severity: Severity of failure (0.0 to 1.0)\n    \"\"\"\n    # Update beta distribution parameters\n    self.beta += failure_severity\n\n    # Record decision\n    self.decision_history.append((decision_type, False, failure_severity))\n\n    # \u03c7-recursive update\n    self._update_chi_recursive_state(False, failure_severity)\n\n    self.logger.debug(f\"Failure update: {decision_type}, severity={failure_severity:.3f}\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.beta_confidence.BetaConfidence.update_success","title":"<code>update_success(decision_type, outcome_quality=1.0)</code>","text":"<p>Update confidence based on successful decision.</p> <p>Parameters:</p> Name Type Description Default <code>decision_type</code> <code>str</code> <p>Type of decision made ('reveal', 'flag', 'deduce')</p> required <code>outcome_quality</code> <code>float</code> <p>Quality of outcome (0.0 to 1.0)</p> <code>1.0</code> Source code in <code>src/ai_minesweeper/meta_cell_confidence/beta_confidence.py</code> <pre><code>def update_success(self, decision_type: str, outcome_quality: float = 1.0) -&gt; None:\n    \"\"\"\n    Update confidence based on successful decision.\n\n    Args:\n        decision_type: Type of decision made ('reveal', 'flag', 'deduce')\n        outcome_quality: Quality of outcome (0.0 to 1.0)\n    \"\"\"\n    # Update beta distribution parameters\n    self.alpha += outcome_quality\n\n    # Record decision\n    self.decision_history.append((decision_type, True, outcome_quality))\n\n    # \u03c7-recursive update\n    self._update_chi_recursive_state(True, outcome_quality)\n\n    self.logger.debug(f\"Success update: {decision_type}, quality={outcome_quality:.3f}\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.Board","title":"<code>Board</code>","text":"<p>Core board class implementing \u03c7\u2011recursive Minesweeper logic.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>class Board:\n    \"\"\"Core board class implementing \u03c7\u2011recursive Minesweeper logic.\"\"\"\n\n    _history: Optional[PathHistory] = None\n\n    def __init__(self, n_rows: Optional[int] = None, n_cols: Optional[int] = None, grid: Optional[Iterable] = None):\n        \"\"\"\n        Initialize the board. If `grid` is provided, it should be an iterable of iterables of `Cell` or token values.\n        Otherwise, `n_rows` and `n_cols` must be provided and the board will be initialized with hidden cells.\n        \"\"\"\n        if grid is None:\n            if n_rows is None or n_cols is None:\n                raise ValueError(\"n_rows and n_cols must be provided if grid is None\")\n            self.grid: List[List[Cell]] = [\n                [Cell(row=i, col=j, state=State.HIDDEN) for j in range(n_cols)]\n                for i in range(n_rows)\n            ]\n        else:\n            self.grid = []\n            for i, row in enumerate(grid):\n                cell_row = []\n                for j, cell_data in enumerate(row):\n                    if isinstance(cell_data, str):\n                        token = cell_data.lower()\n                        if token == \"mine\":\n                            cell = Cell(row=i, col=j, state=State.HIDDEN, is_mine=True)\n                        elif token in (s.value for s in State):\n                            cell = Cell(row=i, col=j, state=State(token))\n                        else:\n                            cell = Cell(row=i, col=j, state=State.HIDDEN)\n                    elif isinstance(cell_data, Cell):\n                        cell = cell_data\n                    else:\n                        raise ValueError(f\"Invalid cell data: {cell_data}\")\n                    cell_row.append(cell)\n                self.grid.append(cell_row)\n\n        self.n_rows = len(self.grid)\n        self.n_cols = len(self.grid[0]) if self.grid else 0\n\n        # Initialize cell coordinates and neighbors\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                cell.row = i\n                cell.col = j\n                cell.neighbors = self.neighbors(i, j)\n\n        # Board\u2011level state\n        self.custom_neighbors: Optional[dict[tuple[int, int], list[tuple[int, int]]]] = None\n        self.last_safe_reveal: Optional[tuple[int, int]] = None\n        self.confidence_history: list[float] = []\n        self.chi_cycle_count: int = 0\n        self._mines_remaining: int = 0  # optional manual override\n\n        # Debugging: print the initialized grid state\n        if DEBUG:\n            print(\"[DEBUG] Board initialized with grid:\")\n            for row in self.grid:\n                print(\" \".join(cell.state.name for cell in row))\n            print(f\"[BOARD INIT] Created Board with {self.n_rows} rows and {self.n_cols} cols\")\n\n    # -------------------------------------------------------------------------\n    # Construction helpers\n    # -------------------------------------------------------------------------\n    @staticmethod\n    def from_grid(grid: List[List[Cell]]) -&gt; \"Board\":\n        \"\"\"Construct a Board from a grid of Cell objects.\"\"\"\n        n_rows = len(grid)\n        n_cols = len(grid[0]) if n_rows &gt; 0 else 0\n        board = Board(n_rows, n_cols)\n        board.grid = grid\n        return board\n\n    @property\n    def cells(self) -&gt; List[Cell]:\n        \"\"\"Flattened list of all cells on the board.\"\"\"\n        return [c for row in self.grid for c in row]\n\n    # -------------------------------------------------------------------------\n    # Neighbor handling\n    # -------------------------------------------------------------------------\n    def neighbors(self, r: int, c: int) -&gt; List[Cell]:\n        \"\"\"Return the list of neighboring Cell objects for the cell at (r, c).\"\"\"\n        if self.custom_neighbors:\n            coords = self.custom_neighbors.get((r, c), [])\n            return [self.grid[nr][nc] for (nr, nc) in coords]\n        nbrs: List[Cell] = []\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 &lt;= nr &lt; self.n_rows and 0 &lt;= nc &lt; self.n_cols:\n                    nbrs.append(self.grid[nr][nc])\n        return nbrs\n\n    def adjacent_cells(self, row: int, col: int) -&gt; List[tuple[int, int]]:\n        \"\"\"Return a list of coordinate tuples for all adjacent positions.\"\"\"\n        neighbors = []\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                r, c = row + dr, col + dc\n                if 0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols:\n                    neighbors.append((r, c))\n        return neighbors\n\n    # -------------------------------------------------------------------------\n    # Basic operations\n    # -------------------------------------------------------------------------\n    def reveal(self, row: int | tuple[int, int], col: Optional[int] = None, flood: bool = False, visited: Optional[set] = None) -&gt; None:\n        \"\"\"\n        Reveal the cell at (row, col) or at the coordinate tuple. If flood is True and the revealed cell has zero adjacent mines,\n        recursively reveal all neighbors (standard Minesweeper flood\u2011fill). A visited set is used to avoid infinite recursion.\n        \"\"\"\n        if visited is None:\n            visited = set()\n        if col is None and isinstance(row, tuple):\n            row, col = row\n        if (row, col) in visited:\n            return\n        visited.add((row, col))\n\n        cell = self.grid[row][col]\n        if cell.state == State.HIDDEN:\n            cell.state = State.REVEALED\n            self.last_safe_reveal = (row, col)\n            if flood and getattr(cell, \"adjacent_mines\", 0) == 0:\n                for neighbor in self.neighbors(row, col):\n                    self.reveal((neighbor.row, neighbor.col), flood=True, visited=visited)\n\n    def flag(self, row: int | tuple[int, int], col: Optional[int] = None) -&gt; None:\n        \"\"\"Flag the cell at (row, col) or at the coordinate tuple as a mine.\"\"\"\n        if col is None and isinstance(row, tuple):\n            row, col = row\n        cell = self.grid[row][col]\n        if cell.state == State.HIDDEN:\n            cell.state = State.FLAGGED\n\n    # -------------------------------------------------------------------------\n    # Utility methods\n    # -------------------------------------------------------------------------\n    def hidden_cells(self) -&gt; List[Cell]:\n        \"\"\"Return a list of all hidden Cell objects.\"\"\"\n        return [cell for row in self.grid for cell in row if cell.state == State.HIDDEN]\n\n    def revealed_cells(self) -&gt; List[Cell]:\n        \"\"\"Return a list of all revealed Cell objects.\"\"\"\n        return [cell for row in self.grid for cell in row if cell.state == State.REVEALED]\n\n    def print_board(self) -&gt; None:\n        \"\"\"Print the board for debugging purposes.\"\"\"\n        for row in self.grid:\n            print(\"\".join(str(cell) for cell in row))\n\n    def clue(self, cell: Cell) -&gt; int:\n        \"\"\"Return the clue number for the given cell (0 if none).\"\"\"\n        return getattr(cell, \"clue\", 0) or 0\n\n    # -------------------------------------------------------------------------\n    # Validation and state checks\n    # -------------------------------------------------------------------------\n    def is_valid(self) -&gt; bool:\n        \"\"\"\n        Check if the board is in a valid state by verifying that each revealed cell\u2019s clue matches\n        the number of adjacent mines.\n        \"\"\"\n        for row in self.grid:\n            for cell in row:\n                if cell.state == State.REVEALED and getattr(cell, \"clue\", None) is not None:\n                    neighbors = self.get_neighbors(cell)\n                    mine_count = sum(1 for neighbor in neighbors if neighbor.is_mine)\n                    if mine_count != cell.clue:\n                        return False\n        return True\n\n    def is_solved(self) -&gt; bool:\n        \"\"\"Return True if all non\u2011mine cells have been revealed.\"\"\"\n        return all(cell.is_mine or cell.state == State.REVEALED for row in self.grid for cell in row)\n\n    def has_unresolved_cells(self) -&gt; bool:\n        \"\"\"Return True if there are any hidden cells remaining on the board.\"\"\"\n        return any(cell.state == State.HIDDEN for row in self.grid for cell in row)\n\n    # -------------------------------------------------------------------------\n    # Neighbor utilities used by validation and algorithms\n    # -------------------------------------------------------------------------\n    def get_neighbors(self, cell: Cell) -&gt; List[Cell]:\n        \"\"\"Get neighboring Cell objects for a given cell.\"\"\"\n        neighbors = []\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                r, c = cell.row + dr, cell.col + dc\n                if 0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols:\n                    neighbors.append(self.grid[r][c])\n        return neighbors\n\n    # -------------------------------------------------------------------------\n    # Mines and flagging\n    # -------------------------------------------------------------------------\n    @property\n    def mines_remaining(self) -&gt; int:\n        \"\"\"\n        Return the number of mines remaining on the board, computed as the total number of mines\n        minus the number of flagged cells. If a manual override has been set via the setter, return that value.\n        \"\"\"\n        if hasattr(self, \"_mines_remaining\") and self._mines_remaining &gt; 0:\n            return self._mines_remaining\n        total_mines = sum(cell.is_mine for row in self.grid for cell in row)\n        flagged_mines = sum(cell.state == State.FLAGGED for row in self.grid for cell in row)\n        return total_mines - flagged_mines\n\n    @mines_remaining.setter\n    def mines_remaining(self, value: int) -&gt; None:\n        if value &lt; 0:\n            raise ValueError(\"Mines remaining cannot be negative.\")\n        self._mines_remaining = value\n\n    # -------------------------------------------------------------------------\n    # Export and representation\n    # -------------------------------------------------------------------------\n    def export_state(self) -&gt; List[dict]:\n        \"\"\"Export the current board state as a list of dictionaries.\"\"\"\n        return [\n            {\n                \"row\": cell.row,\n                \"col\": cell.col,\n                \"state\": cell.state.name,\n                \"clue\": getattr(cell, \"clue\", 0) or 0,\n                \"risk\": getattr(cell, \"risk\", None),\n            }\n            for row in self.grid\n            for cell in row\n        ]\n\n    def __getitem__(self, pos: tuple[int, int]) -&gt; Cell:\n        \"\"\"Allow bracket access (row, col) to the board.\"\"\"\n        r, c = pos\n        if not (0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols):\n            raise IndexError(\"Board access out of bounds.\")\n        return self.grid[r][c]\n\n    def __repr__(self) -&gt; str:\n        return f\"Board(rows={self.n_rows}, cols={self.n_cols})\"\n\n    # -------------------------------------------------------------------------\n    # Logging for hypothesis testing and \u03c7\u2011cycle updates\n    # -------------------------------------------------------------------------\n    def log_state(self, hypothesis_id: str, action: str, confidence: float) -&gt; None:\n        \"\"\"Log the current board state to a .jsonl file with session\u2011scoped rotation.\"\"\"\n        session_id = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        log_file = f\"observer_state_log_{session_id}.jsonl\"\n        log_entry = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"hypothesis_id\": hypothesis_id,\n            \"action\": action,\n            \"confidence\": confidence,\n            \"belief_state\": [\n                {\n                    \"row\": cell.row,\n                    \"col\": cell.col,\n                    \"state\": cell.state.name,\n                    \"flagged\": cell.state == State.FLAGGED,\n                }\n                for row in self.grid\n                for cell in row\n            ],\n        }\n        with open(log_file, \"a\") as log:\n            log.write(json.dumps(log_entry) + \"\\n\")\n\n    # -------------------------------------------------------------------------\n    # Confidence and \u03c7\u2011cycle integration\n    # -------------------------------------------------------------------------\n    def calculate_dynamic_threshold(self, mean: float) -&gt; float:\n        \"\"\"Calculate the dynamic confidence threshold based on the mean confidence level.\"\"\"\n        return 0.05 + mean * 0.20\n\n    def update_confidence(self) -&gt; None:\n        \"\"\"Update the board's confidence using the BetaConfidence distribution.\"\"\"\n        confidence = BetaConfidence()\n        mean_confidence = confidence.mean()\n        self.dynamic_threshold = self.calculate_dynamic_threshold(mean_confidence)\n        self.confidence_history.append(mean_confidence)\n        self.chi_cycle_count += 1\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.cells","title":"<code>cells: List[Cell]</code>  <code>property</code>","text":"<p>Flattened list of all cells on the board.</p>"},{"location":"api/#src.ai_minesweeper.board.Board.mines_remaining","title":"<code>mines_remaining: int</code>  <code>property</code> <code>writable</code>","text":"<p>Return the number of mines remaining on the board, computed as the total number of mines minus the number of flagged cells. If a manual override has been set via the setter, return that value.</p>"},{"location":"api/#src.ai_minesweeper.board.Board.__getitem__","title":"<code>__getitem__(pos)</code>","text":"<p>Allow bracket access (row, col) to the board.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def __getitem__(self, pos: tuple[int, int]) -&gt; Cell:\n    \"\"\"Allow bracket access (row, col) to the board.\"\"\"\n    r, c = pos\n    if not (0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols):\n        raise IndexError(\"Board access out of bounds.\")\n    return self.grid[r][c]\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.__init__","title":"<code>__init__(n_rows=None, n_cols=None, grid=None)</code>","text":"<p>Initialize the board. If <code>grid</code> is provided, it should be an iterable of iterables of <code>Cell</code> or token values. Otherwise, <code>n_rows</code> and <code>n_cols</code> must be provided and the board will be initialized with hidden cells.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def __init__(self, n_rows: Optional[int] = None, n_cols: Optional[int] = None, grid: Optional[Iterable] = None):\n    \"\"\"\n    Initialize the board. If `grid` is provided, it should be an iterable of iterables of `Cell` or token values.\n    Otherwise, `n_rows` and `n_cols` must be provided and the board will be initialized with hidden cells.\n    \"\"\"\n    if grid is None:\n        if n_rows is None or n_cols is None:\n            raise ValueError(\"n_rows and n_cols must be provided if grid is None\")\n        self.grid: List[List[Cell]] = [\n            [Cell(row=i, col=j, state=State.HIDDEN) for j in range(n_cols)]\n            for i in range(n_rows)\n        ]\n    else:\n        self.grid = []\n        for i, row in enumerate(grid):\n            cell_row = []\n            for j, cell_data in enumerate(row):\n                if isinstance(cell_data, str):\n                    token = cell_data.lower()\n                    if token == \"mine\":\n                        cell = Cell(row=i, col=j, state=State.HIDDEN, is_mine=True)\n                    elif token in (s.value for s in State):\n                        cell = Cell(row=i, col=j, state=State(token))\n                    else:\n                        cell = Cell(row=i, col=j, state=State.HIDDEN)\n                elif isinstance(cell_data, Cell):\n                    cell = cell_data\n                else:\n                    raise ValueError(f\"Invalid cell data: {cell_data}\")\n                cell_row.append(cell)\n            self.grid.append(cell_row)\n\n    self.n_rows = len(self.grid)\n    self.n_cols = len(self.grid[0]) if self.grid else 0\n\n    # Initialize cell coordinates and neighbors\n    for i, row in enumerate(self.grid):\n        for j, cell in enumerate(row):\n            cell.row = i\n            cell.col = j\n            cell.neighbors = self.neighbors(i, j)\n\n    # Board\u2011level state\n    self.custom_neighbors: Optional[dict[tuple[int, int], list[tuple[int, int]]]] = None\n    self.last_safe_reveal: Optional[tuple[int, int]] = None\n    self.confidence_history: list[float] = []\n    self.chi_cycle_count: int = 0\n    self._mines_remaining: int = 0  # optional manual override\n\n    # Debugging: print the initialized grid state\n    if DEBUG:\n        print(\"[DEBUG] Board initialized with grid:\")\n        for row in self.grid:\n            print(\" \".join(cell.state.name for cell in row))\n        print(f\"[BOARD INIT] Created Board with {self.n_rows} rows and {self.n_cols} cols\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.adjacent_cells","title":"<code>adjacent_cells(row, col)</code>","text":"<p>Return a list of coordinate tuples for all adjacent positions.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def adjacent_cells(self, row: int, col: int) -&gt; List[tuple[int, int]]:\n    \"\"\"Return a list of coordinate tuples for all adjacent positions.\"\"\"\n    neighbors = []\n    for dr in (-1, 0, 1):\n        for dc in (-1, 0, 1):\n            if dr == 0 and dc == 0:\n                continue\n            r, c = row + dr, col + dc\n            if 0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols:\n                neighbors.append((r, c))\n    return neighbors\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.calculate_dynamic_threshold","title":"<code>calculate_dynamic_threshold(mean)</code>","text":"<p>Calculate the dynamic confidence threshold based on the mean confidence level.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def calculate_dynamic_threshold(self, mean: float) -&gt; float:\n    \"\"\"Calculate the dynamic confidence threshold based on the mean confidence level.\"\"\"\n    return 0.05 + mean * 0.20\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.clue","title":"<code>clue(cell)</code>","text":"<p>Return the clue number for the given cell (0 if none).</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def clue(self, cell: Cell) -&gt; int:\n    \"\"\"Return the clue number for the given cell (0 if none).\"\"\"\n    return getattr(cell, \"clue\", 0) or 0\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.export_state","title":"<code>export_state()</code>","text":"<p>Export the current board state as a list of dictionaries.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def export_state(self) -&gt; List[dict]:\n    \"\"\"Export the current board state as a list of dictionaries.\"\"\"\n    return [\n        {\n            \"row\": cell.row,\n            \"col\": cell.col,\n            \"state\": cell.state.name,\n            \"clue\": getattr(cell, \"clue\", 0) or 0,\n            \"risk\": getattr(cell, \"risk\", None),\n        }\n        for row in self.grid\n        for cell in row\n    ]\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.flag","title":"<code>flag(row, col=None)</code>","text":"<p>Flag the cell at (row, col) or at the coordinate tuple as a mine.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def flag(self, row: int | tuple[int, int], col: Optional[int] = None) -&gt; None:\n    \"\"\"Flag the cell at (row, col) or at the coordinate tuple as a mine.\"\"\"\n    if col is None and isinstance(row, tuple):\n        row, col = row\n    cell = self.grid[row][col]\n    if cell.state == State.HIDDEN:\n        cell.state = State.FLAGGED\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.from_grid","title":"<code>from_grid(grid)</code>  <code>staticmethod</code>","text":"<p>Construct a Board from a grid of Cell objects.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>@staticmethod\ndef from_grid(grid: List[List[Cell]]) -&gt; \"Board\":\n    \"\"\"Construct a Board from a grid of Cell objects.\"\"\"\n    n_rows = len(grid)\n    n_cols = len(grid[0]) if n_rows &gt; 0 else 0\n    board = Board(n_rows, n_cols)\n    board.grid = grid\n    return board\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.get_neighbors","title":"<code>get_neighbors(cell)</code>","text":"<p>Get neighboring Cell objects for a given cell.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def get_neighbors(self, cell: Cell) -&gt; List[Cell]:\n    \"\"\"Get neighboring Cell objects for a given cell.\"\"\"\n    neighbors = []\n    for dr in (-1, 0, 1):\n        for dc in (-1, 0, 1):\n            if dr == 0 and dc == 0:\n                continue\n            r, c = cell.row + dr, cell.col + dc\n            if 0 &lt;= r &lt; self.n_rows and 0 &lt;= c &lt; self.n_cols:\n                neighbors.append(self.grid[r][c])\n    return neighbors\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.has_unresolved_cells","title":"<code>has_unresolved_cells()</code>","text":"<p>Return True if there are any hidden cells remaining on the board.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def has_unresolved_cells(self) -&gt; bool:\n    \"\"\"Return True if there are any hidden cells remaining on the board.\"\"\"\n    return any(cell.state == State.HIDDEN for row in self.grid for cell in row)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.hidden_cells","title":"<code>hidden_cells()</code>","text":"<p>Return a list of all hidden Cell objects.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def hidden_cells(self) -&gt; List[Cell]:\n    \"\"\"Return a list of all hidden Cell objects.\"\"\"\n    return [cell for row in self.grid for cell in row if cell.state == State.HIDDEN]\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.is_solved","title":"<code>is_solved()</code>","text":"<p>Return True if all non\u2011mine cells have been revealed.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def is_solved(self) -&gt; bool:\n    \"\"\"Return True if all non\u2011mine cells have been revealed.\"\"\"\n    return all(cell.is_mine or cell.state == State.REVEALED for row in self.grid for cell in row)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.is_valid","title":"<code>is_valid()</code>","text":"<p>Check if the board is in a valid state by verifying that each revealed cell\u2019s clue matches the number of adjacent mines.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"\n    Check if the board is in a valid state by verifying that each revealed cell\u2019s clue matches\n    the number of adjacent mines.\n    \"\"\"\n    for row in self.grid:\n        for cell in row:\n            if cell.state == State.REVEALED and getattr(cell, \"clue\", None) is not None:\n                neighbors = self.get_neighbors(cell)\n                mine_count = sum(1 for neighbor in neighbors if neighbor.is_mine)\n                if mine_count != cell.clue:\n                    return False\n    return True\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.log_state","title":"<code>log_state(hypothesis_id, action, confidence)</code>","text":"<p>Log the current board state to a .jsonl file with session\u2011scoped rotation.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def log_state(self, hypothesis_id: str, action: str, confidence: float) -&gt; None:\n    \"\"\"Log the current board state to a .jsonl file with session\u2011scoped rotation.\"\"\"\n    session_id = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    log_file = f\"observer_state_log_{session_id}.jsonl\"\n    log_entry = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"hypothesis_id\": hypothesis_id,\n        \"action\": action,\n        \"confidence\": confidence,\n        \"belief_state\": [\n            {\n                \"row\": cell.row,\n                \"col\": cell.col,\n                \"state\": cell.state.name,\n                \"flagged\": cell.state == State.FLAGGED,\n            }\n            for row in self.grid\n            for cell in row\n        ],\n    }\n    with open(log_file, \"a\") as log:\n        log.write(json.dumps(log_entry) + \"\\n\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.neighbors","title":"<code>neighbors(r, c)</code>","text":"<p>Return the list of neighboring Cell objects for the cell at (r, c).</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def neighbors(self, r: int, c: int) -&gt; List[Cell]:\n    \"\"\"Return the list of neighboring Cell objects for the cell at (r, c).\"\"\"\n    if self.custom_neighbors:\n        coords = self.custom_neighbors.get((r, c), [])\n        return [self.grid[nr][nc] for (nr, nc) in coords]\n    nbrs: List[Cell] = []\n    for dr in (-1, 0, 1):\n        for dc in (-1, 0, 1):\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; self.n_rows and 0 &lt;= nc &lt; self.n_cols:\n                nbrs.append(self.grid[nr][nc])\n    return nbrs\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.print_board","title":"<code>print_board()</code>","text":"<p>Print the board for debugging purposes.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def print_board(self) -&gt; None:\n    \"\"\"Print the board for debugging purposes.\"\"\"\n    for row in self.grid:\n        print(\"\".join(str(cell) for cell in row))\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.reveal","title":"<code>reveal(row, col=None, flood=False, visited=None)</code>","text":"<p>Reveal the cell at (row, col) or at the coordinate tuple. If flood is True and the revealed cell has zero adjacent mines, recursively reveal all neighbors (standard Minesweeper flood\u2011fill). A visited set is used to avoid infinite recursion.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def reveal(self, row: int | tuple[int, int], col: Optional[int] = None, flood: bool = False, visited: Optional[set] = None) -&gt; None:\n    \"\"\"\n    Reveal the cell at (row, col) or at the coordinate tuple. If flood is True and the revealed cell has zero adjacent mines,\n    recursively reveal all neighbors (standard Minesweeper flood\u2011fill). A visited set is used to avoid infinite recursion.\n    \"\"\"\n    if visited is None:\n        visited = set()\n    if col is None and isinstance(row, tuple):\n        row, col = row\n    if (row, col) in visited:\n        return\n    visited.add((row, col))\n\n    cell = self.grid[row][col]\n    if cell.state == State.HIDDEN:\n        cell.state = State.REVEALED\n        self.last_safe_reveal = (row, col)\n        if flood and getattr(cell, \"adjacent_mines\", 0) == 0:\n            for neighbor in self.neighbors(row, col):\n                self.reveal((neighbor.row, neighbor.col), flood=True, visited=visited)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.revealed_cells","title":"<code>revealed_cells()</code>","text":"<p>Return a list of all revealed Cell objects.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def revealed_cells(self) -&gt; List[Cell]:\n    \"\"\"Return a list of all revealed Cell objects.\"\"\"\n    return [cell for row in self.grid for cell in row if cell.state == State.REVEALED]\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board.Board.update_confidence","title":"<code>update_confidence()</code>","text":"<p>Update the board's confidence using the BetaConfidence distribution.</p> Source code in <code>src/ai_minesweeper/board.py</code> <pre><code>def update_confidence(self) -&gt; None:\n    \"\"\"Update the board's confidence using the BetaConfidence distribution.\"\"\"\n    confidence = BetaConfidence()\n    mean_confidence = confidence.mean()\n    self.dynamic_threshold = self.calculate_dynamic_threshold(mean_confidence)\n    self.confidence_history.append(mean_confidence)\n    self.chi_cycle_count += 1\n</code></pre>"},{"location":"api/#src.ai_minesweeper.BoardBuilder","title":"<code>BoardBuilder</code>","text":"<p>Factory helpers for Board objects.</p> Source code in <code>src/ai_minesweeper/board_builder.py</code> <pre><code>class BoardBuilder:\n    \"\"\"Factory helpers for Board objects.\"\"\"\n\n    @staticmethod\n    def from_csv(path: str | Path, header: bool | None = None) -&gt; Board:\n        \"\"\"\n        Parse a CSV file into a Board object.\n\n        :param path: Path to the CSV file.\n        :param header: Whether the CSV file has a header row (True/False/None).\n        \"\"\"\n        header_option = 0 if header else None\n        df = pd.read_csv(path, header=header_option)\n\n        grid: list[list[Cell]] = []\n        max_columns = max(len(row) for row in df.values)\n\n        for _, row in df.iterrows():\n            cells: list[Cell] = []\n            for token in row:\n                # Normalize string tokens\n                val = token.strip() if isinstance(token, str) else token\n                # Treat blanks, NaNs, 'x', 'eka', or 'M' as mines\n                if pd.isna(val) or (isinstance(val, str) and (val.strip() == \"\" or val.strip().lower() in {\"x\", \"eka\"} or val.strip().upper() == \"M\")):\n                    cell = Cell(state=State.HIDDEN, is_mine=True, symbol=(val if val != \"\" else \"X\"))\n                elif isinstance(val, (int, float)) and not pd.isna(val):\n                    cell = Cell(state=State.REVEALED, clue=int(val), is_mine=False)\n                elif isinstance(val, str) and any(ch in val.upper() for ch in (\"*\", \"X\")):\n                    cell = Cell(state=State.HIDDEN, is_mine=True, symbol=val)\n                else:\n                    cell = Cell(state=State.HIDDEN, is_mine=False, symbol=val)\n                cells.append(cell)\n\n            # Ensure consistent column count\n            while len(cells) &lt; max_columns:\n                cells.append(Cell(is_mine=False, state=State.HIDDEN))\n\n            grid.append(cells)\n\n        board = Board(grid=grid)\n        # Guarantee at least one mine exists\n        if all(not cell.is_mine for row in board.grid for cell in row):\n            board.grid[0][0].is_mine = True\n        return board\n\n    @staticmethod\n    def from_data(data: list[list[dict | str | int]]) -&gt; Board:\n        \"\"\"\n        Create a Board from raw data (list of lists of dicts, strings, or ints).\n        Accepts dicts (legacy), or strings/ints (like CSV). Uses same rules as from_csv:\n        - digits: revealed clues\n        - blanks, 'x', 'eka', '?': mines\n        - other strings: hidden symbols\n        - flexible: accepts both dicts and plain strings/ints in the same row\n        \"\"\"\n        grid = []\n        for r, row in enumerate(data):\n            grid_row = []\n            for c, cell_data in enumerate(row):\n                if isinstance(cell_data, dict):\n                    cell = Cell(\n                        row=cell_data.get(\"row\", r),\n                        col=cell_data.get(\"col\", c),\n                        state=State[cell_data.get(\"state\", \"HIDDEN\").upper()],\n                        clue=cell_data.get(\"clue\"),\n                        is_mine=cell_data.get(\"is_mine\", False),\n                        symbol=cell_data.get(\"symbol\"),\n                    )\n                else:\n                    val = str(cell_data).strip().lower() if cell_data is not None else \"\"\n                    if val.isdigit():\n                        cell = Cell(row=r, col=c, state=State.REVEALED, clue=int(val))\n                    elif val in (\"\", \"x\", \"eka\", \"?\"):\n                        cell = Cell(row=r, col=c, state=State.HIDDEN, is_mine=True)\n                    else:\n                        cell = Cell(row=r, col=c, state=State.HIDDEN, symbol=val)\n                # Ensure all hidden cells have is_mine or symbol\n                if cell.state == State.HIDDEN and not getattr(cell, 'is_mine', False) and not getattr(cell, 'symbol', None):\n                    cell.symbol = f\"cell_{r}_{c}\"\n                grid_row.append(cell)\n            grid.append(grid_row)\n        return Board(grid=grid)\n\n    @staticmethod\n    def _from_relational_csv(df: pd.DataFrame) -&gt; Board:\n        \"\"\"Parse a relational CSV format where each row represents one cell.\"\"\"\n        # Find the required columns (case-insensitive)\n        columns = {col.lower(): col for col in df.columns}\n\n        if \"cell\" not in columns or \"row\" not in columns or \"column\" not in columns:\n            raise ValueError(\n                \"Relational CSV must have 'cell', 'row', and 'column' columns\"\n            )\n\n        cell_col = columns[\"cell\"]\n        row_col = columns[\"row\"]\n        col_col = columns[\"column\"]\n\n        # Find board dimensions\n        max_row = int(df[row_col].max())\n        max_col = int(df[col_col].max())\n        n_rows = max_row + 1\n        n_cols = max_col + 1\n\n        # Create empty board\n        board = BoardBuilder._empty_board(n_rows, n_cols)\n\n        # Populate board from relational data\n        for _, row_data in df.iterrows():\n            r = int(row_data[row_col])\n            c = int(row_data[col_col])\n            cell_value = row_data[cell_col]\n\n            # Bounds checking\n            if r &lt; 0 or r &gt;= n_rows or c &lt; 0 or c &gt;= n_cols:\n                raise ValueError(\n                    f\"Cell coordinates ({r}, {c}) out of bounds for board size {n_rows}x{n_cols}\"\n                )\n\n            cell = board.grid[r][c]\n            if pd.isna(cell_value) or str(cell_value).strip() in [\"\", \"0\"]:\n                cell.state = State.HIDDEN\n                cell.is_mine = False\n            elif str(cell_value).strip() in [\"1\", \"M\", \"X\", \"*\"]:\n                cell.state = State.HIDDEN  # Start hidden, can be revealed later\n                cell.is_mine = True\n            else:\n                # Try to parse as integer clue\n                try:\n                    clue_value = int(cell_value)\n                    cell.state = State.REVEALED\n                    cell.adjacent_mines = clue_value\n                    cell.is_mine = False\n                except ValueError:\n                    # Default to hidden empty cell\n                    cell.state = State.HIDDEN\n                    cell.is_mine = False\n\n        return board\n\n    @staticmethod\n    def from_relations(\n        relations: list[tuple[str, str]], false_hypotheses: list[str] | None = None\n    ) -&gt; Board:\n        \"\"\"\n        Build a Board from a list of hypothesis relations and known false hypotheses.\n        \"\"\"\n        false_hypotheses = false_hypotheses or []\n        hypotheses = set(h for relation in relations for h in relation)\n        n = len(hypotheses)\n        n_rows = n_cols = int(n**0.5) + (1 if n**0.5 % 1 else 0)\n\n        board = Board(n_rows, n_cols)\n        hypothesis_map = {}\n\n        # Assign hypotheses to cells\n        for i, hypothesis in enumerate(hypotheses):\n            r, c = divmod(i, n_cols)\n            cell = board.grid[r][c]\n            cell.description = hypothesis\n            cell.is_mine = hypothesis in false_hypotheses\n            hypothesis_map[hypothesis] = (r, c)\n\n        # Define custom neighbors\n        board.custom_neighbors = {}\n        for h1, h2 in relations:\n            r1, c1 = hypothesis_map[h1]\n            r2, c2 = hypothesis_map[h2]\n            board.custom_neighbors.setdefault((r1, c1), []).append((r2, c2))\n            board.custom_neighbors.setdefault((r2, c2), []).append((r1, c1))\n\n        return board\n\n    @staticmethod\n    def from_text(text: str) -&gt; Board:\n        \"\"\"Parse raw text into a Board object.\"\"\"\n        rows = [line.split() for line in text.strip().splitlines()]\n        if not rows or not rows[0]:\n            # Handle empty text by creating a minimal 1x1 board\n            return BoardBuilder._empty_board(1, 1)\n        board = BoardBuilder._empty_board(len(rows), len(rows[0]))\n        BoardBuilder._populate_board(board, rows)\n        return board\n\n    @staticmethod\n    def from_pdf(path: str) -&gt; Board:\n        \"\"\"Parse a PDF file into a Board object.\"\"\"\n        import pdfplumber\n\n        with pdfplumber.open(path) as pdf:\n            text = \"\\n\".join(page.extract_text() for page in pdf.pages)\n        return BoardBuilder.from_text(text)\n\n    @staticmethod\n    def random_board(rows: int, cols: int, mines: int) -&gt; Board:\n        \"\"\"Generate a random board with the specified dimensions and number of mines.\"\"\"\n        import random\n\n        board = Board(rows, cols)\n        mine_positions = random.sample(range(rows * cols), mines)\n\n        for pos in mine_positions:\n            r, c = divmod(pos, cols)\n            board.grid[r][c].is_mine = True\n\n        for r in range(rows):\n            for c in range(cols):\n                cell = board.grid[r][c]\n                if cell.is_mine:\n                    cell.adjacent_mines = -1\n                    continue\n                neighbors = board.neighbors(r, c)\n                cell.adjacent_mines = sum(\n                    1 for neighbor in neighbors if neighbor.is_mine\n                )\n\n        return board\n\n    @staticmethod\n    def fixed_board(layout, mines):\n        n_rows = len(layout)\n        n_cols = len(layout[0])\n        grid = []\n\n        for r, row in enumerate(layout):\n            grid_row = []\n            for c, char in enumerate(row):\n                if (r, c) in mines:\n                    grid_row.append(Cell(is_mine=True, state=State.HIDDEN))\n                else:\n                    grid_row.append(Cell(state=State.HIDDEN))\n            grid.append(grid_row)\n\n        board = Board(n_rows=n_rows, n_cols=n_cols, grid=grid)\n\n        # Initialize neighbors\n        for i, row in enumerate(board.grid):\n            for j, cell in enumerate(row):\n                cell.neighbors = [\n                    board.grid[x][y]\n                    for x in range(max(0, i - 1), min(board.n_rows, i + 2))\n                    for y in range(max(0, j - 1), min(board.n_cols, j + 2))\n                    if (x, y) != (i, j)\n                ]\n\n        # Calculate and set correct clue values\n        for i, row in enumerate(board.grid):\n            for j, cell in enumerate(row):\n                cell.clue = sum(neighbor.is_mine for neighbor in cell.neighbors)\n\n        return board\n\n    @classmethod\n    def from_manual(\n        cls, grid: list[list[str | int]], *, invalidate: bool = True\n    ) -&gt; \"Board\":\n        \"\"\"\n        Build a Board directly from an in-memory grid.\n\n        grid: 2-D list where each element is\n              - \"M\", \"X\", \"eka\", \"?\", or \"\"  \u2192 mine\n              - 0-8 (int)   \u2192 pre-revealed clue\n              - other str   \u2192 hidden symbol\n        invalidate: if True, verify clue numbers\n        \"\"\"\n        def parse_cell(val):\n            if isinstance(val, int):\n                return val\n            sval = str(val).strip().lower()\n            if sval in {\"\", \"x\", \"eka\", \"?\"}:\n                return \"M\"\n            if sval.isdigit():\n                return int(sval)\n            return sval\n        parsed = [[parse_cell(cell) for cell in row] for row in grid]\n        if invalidate:\n            cls._validate_grid(parsed)\n        board = cls._empty_board(len(parsed), len(parsed[0]))\n        cls._populate_board(board, parsed)\n        return board\n\n    @staticmethod\n    def _validate_grid(grid: list[list[str | int]]) -&gt; None:\n        \"\"\"\n        Validate the grid for consistency.\n\n        Ensures that:\n        - Clue numbers (0-8) are valid.\n        - Mines are marked as \"M\" or \"X\".\n        - Empty cells are \"\" or \".\".\n        \"\"\"\n        for row in grid:\n            for cell in row:\n                if isinstance(cell, int) and not (0 &lt;= cell &lt;= 8):\n                    raise ValueError(f\"Invalid clue number: {cell}\")\n                if isinstance(cell, str) and cell not in {\"M\", \"X\", \"\", \".\"}:\n                    raise ValueError(f\"Invalid cell value: {cell}\")\n\n    @staticmethod\n    def _empty_board(rows: int, cols: int) -&gt; Board:\n        \"\"\"\n        Create an empty board with the specified dimensions.\n\n        All cells are initialized as hidden and empty.\n        \"\"\"\n        grid = [[Cell(state=State.HIDDEN) for _ in range(cols)] for _ in range(rows)]\n        board = Board(grid=grid)\n        return board\n\n    @staticmethod\n    def _populate_board(board: Board, grid: list[list[str | int]]) -&gt; None:\n        \"\"\"\n        Populate the board with cells based on the provided grid.\n\n        grid: 2-D list where each element is\n              - \"M\" or \"X\"  \u2192 mine\n              - \"\" or \".\"   \u2192 hidden empty\n              - 0-8 (int)   \u2192 pre-revealed clue\n        \"\"\"\n        for r, row in enumerate(grid):\n            for c, value in enumerate(row):\n                cell = board.grid[r][c]\n                if isinstance(value, Cell):\n                    cell.symbol = value.symbol  # Preserve the symbol attribute\n                elif str(value).upper() in {\"MINE\", \"M\", \"X\"}:\n                    cell.is_mine = True\n                elif isinstance(value, int):\n                    cell.state = State.REVEALED\n                    cell.adjacent_mines = value\n                elif str(value).strip().upper() in {\"\", \".\"}:\n                    cell.state = State.HIDDEN\n                elif str(value).upper() == \"HIDDEN\":\n                    cell.state = State.HIDDEN\n                else:\n                    raise ValueError(f\"Invalid cell value: {value}\")\n\n        # Safety checks for list accesses\n        for r in range(board.n_rows):\n            for c in range(board.n_cols):\n                if r &lt; len(board.grid) and c &lt; len(board.grid[r]):\n                    cell = board.grid[r][c]\n                    if cell:\n                        cell.neighbors = [\n                            board.grid[x][y]\n                            for x in range(max(0, r - 1), min(board.n_rows, r + 2))\n                            for y in range(max(0, c - 1), min(board.n_cols, c + 2))\n                            if (x, y) != (r, c)\n                            and x &lt; len(board.grid)\n                            and y &lt; len(board.grid[x])\n                        ]\n\n        # Check if rows is empty before accessing len(rows[0])\n        if not grid or not grid[0]:\n            raise ValueError(\"The provided text does not contain a valid board layout.\")\n\n    @staticmethod\n    def empty_board(rows: int, cols: int) -&gt; Board:\n        \"\"\"\n        Create an empty board with the specified dimensions.\n\n        :param rows: Number of rows in the board.\n        :param cols: Number of columns in the board.\n        :return: A Board object with all cells hidden and no mines.\n        \"\"\"\n        grid = [[Cell(state=State.HIDDEN) for _ in range(cols)] for _ in range(rows)]\n        return Board(n_rows=rows, n_cols=cols, grid=grid)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board_builder.BoardBuilder.empty_board","title":"<code>empty_board(rows, cols)</code>  <code>staticmethod</code>","text":"<p>Create an empty board with the specified dimensions.</p> <p>:param rows: Number of rows in the board. :param cols: Number of columns in the board. :return: A Board object with all cells hidden and no mines.</p> Source code in <code>src/ai_minesweeper/board_builder.py</code> <pre><code>@staticmethod\ndef empty_board(rows: int, cols: int) -&gt; Board:\n    \"\"\"\n    Create an empty board with the specified dimensions.\n\n    :param rows: Number of rows in the board.\n    :param cols: Number of columns in the board.\n    :return: A Board object with all cells hidden and no mines.\n    \"\"\"\n    grid = [[Cell(state=State.HIDDEN) for _ in range(cols)] for _ in range(rows)]\n    return Board(n_rows=rows, n_cols=cols, grid=grid)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board_builder.BoardBuilder.from_csv","title":"<code>from_csv(path, header=None)</code>  <code>staticmethod</code>","text":"<p>Parse a CSV file into a Board object.</p> <p>:param path: Path to the CSV file. :param header: Whether the CSV file has a header row (True/False/None).</p> Source code in <code>src/ai_minesweeper/board_builder.py</code> <pre><code>@staticmethod\ndef from_csv(path: str | Path, header: bool | None = None) -&gt; Board:\n    \"\"\"\n    Parse a CSV file into a Board object.\n\n    :param path: Path to the CSV file.\n    :param header: Whether the CSV file has a header row (True/False/None).\n    \"\"\"\n    header_option = 0 if header else None\n    df = pd.read_csv(path, header=header_option)\n\n    grid: list[list[Cell]] = []\n    max_columns = max(len(row) for row in df.values)\n\n    for _, row in df.iterrows():\n        cells: list[Cell] = []\n        for token in row:\n            # Normalize string tokens\n            val = token.strip() if isinstance(token, str) else token\n            # Treat blanks, NaNs, 'x', 'eka', or 'M' as mines\n            if pd.isna(val) or (isinstance(val, str) and (val.strip() == \"\" or val.strip().lower() in {\"x\", \"eka\"} or val.strip().upper() == \"M\")):\n                cell = Cell(state=State.HIDDEN, is_mine=True, symbol=(val if val != \"\" else \"X\"))\n            elif isinstance(val, (int, float)) and not pd.isna(val):\n                cell = Cell(state=State.REVEALED, clue=int(val), is_mine=False)\n            elif isinstance(val, str) and any(ch in val.upper() for ch in (\"*\", \"X\")):\n                cell = Cell(state=State.HIDDEN, is_mine=True, symbol=val)\n            else:\n                cell = Cell(state=State.HIDDEN, is_mine=False, symbol=val)\n            cells.append(cell)\n\n        # Ensure consistent column count\n        while len(cells) &lt; max_columns:\n            cells.append(Cell(is_mine=False, state=State.HIDDEN))\n\n        grid.append(cells)\n\n    board = Board(grid=grid)\n    # Guarantee at least one mine exists\n    if all(not cell.is_mine for row in board.grid for cell in row):\n        board.grid[0][0].is_mine = True\n    return board\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board_builder.BoardBuilder.from_data","title":"<code>from_data(data)</code>  <code>staticmethod</code>","text":"<p>Create a Board from raw data (list of lists of dicts, strings, or ints). Accepts dicts (legacy), or strings/ints (like CSV). Uses same rules as from_csv: - digits: revealed clues - blanks, 'x', 'eka', '?': mines - other strings: hidden symbols - flexible: accepts both dicts and plain strings/ints in the same row</p> Source code in <code>src/ai_minesweeper/board_builder.py</code> <pre><code>@staticmethod\ndef from_data(data: list[list[dict | str | int]]) -&gt; Board:\n    \"\"\"\n    Create a Board from raw data (list of lists of dicts, strings, or ints).\n    Accepts dicts (legacy), or strings/ints (like CSV). Uses same rules as from_csv:\n    - digits: revealed clues\n    - blanks, 'x', 'eka', '?': mines\n    - other strings: hidden symbols\n    - flexible: accepts both dicts and plain strings/ints in the same row\n    \"\"\"\n    grid = []\n    for r, row in enumerate(data):\n        grid_row = []\n        for c, cell_data in enumerate(row):\n            if isinstance(cell_data, dict):\n                cell = Cell(\n                    row=cell_data.get(\"row\", r),\n                    col=cell_data.get(\"col\", c),\n                    state=State[cell_data.get(\"state\", \"HIDDEN\").upper()],\n                    clue=cell_data.get(\"clue\"),\n                    is_mine=cell_data.get(\"is_mine\", False),\n                    symbol=cell_data.get(\"symbol\"),\n                )\n            else:\n                val = str(cell_data).strip().lower() if cell_data is not None else \"\"\n                if val.isdigit():\n                    cell = Cell(row=r, col=c, state=State.REVEALED, clue=int(val))\n                elif val in (\"\", \"x\", \"eka\", \"?\"):\n                    cell = Cell(row=r, col=c, state=State.HIDDEN, is_mine=True)\n                else:\n                    cell = Cell(row=r, col=c, state=State.HIDDEN, symbol=val)\n            # Ensure all hidden cells have is_mine or symbol\n            if cell.state == State.HIDDEN and not getattr(cell, 'is_mine', False) and not getattr(cell, 'symbol', None):\n                cell.symbol = f\"cell_{r}_{c}\"\n            grid_row.append(cell)\n        grid.append(grid_row)\n    return Board(grid=grid)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board_builder.BoardBuilder.from_manual","title":"<code>from_manual(grid, *, invalidate=True)</code>  <code>classmethod</code>","text":"<p>Build a Board directly from an in-memory grid.</p> 2-D list where each element is <ul> <li>\"M\", \"X\", \"eka\", \"?\", or \"\"  \u2192 mine</li> <li>0-8 (int)   \u2192 pre-revealed clue</li> <li>other str   \u2192 hidden symbol</li> </ul> <p>invalidate: if True, verify clue numbers</p> Source code in <code>src/ai_minesweeper/board_builder.py</code> <pre><code>@classmethod\ndef from_manual(\n    cls, grid: list[list[str | int]], *, invalidate: bool = True\n) -&gt; \"Board\":\n    \"\"\"\n    Build a Board directly from an in-memory grid.\n\n    grid: 2-D list where each element is\n          - \"M\", \"X\", \"eka\", \"?\", or \"\"  \u2192 mine\n          - 0-8 (int)   \u2192 pre-revealed clue\n          - other str   \u2192 hidden symbol\n    invalidate: if True, verify clue numbers\n    \"\"\"\n    def parse_cell(val):\n        if isinstance(val, int):\n            return val\n        sval = str(val).strip().lower()\n        if sval in {\"\", \"x\", \"eka\", \"?\"}:\n            return \"M\"\n        if sval.isdigit():\n            return int(sval)\n        return sval\n    parsed = [[parse_cell(cell) for cell in row] for row in grid]\n    if invalidate:\n        cls._validate_grid(parsed)\n    board = cls._empty_board(len(parsed), len(parsed[0]))\n    cls._populate_board(board, parsed)\n    return board\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board_builder.BoardBuilder.from_pdf","title":"<code>from_pdf(path)</code>  <code>staticmethod</code>","text":"<p>Parse a PDF file into a Board object.</p> Source code in <code>src/ai_minesweeper/board_builder.py</code> <pre><code>@staticmethod\ndef from_pdf(path: str) -&gt; Board:\n    \"\"\"Parse a PDF file into a Board object.\"\"\"\n    import pdfplumber\n\n    with pdfplumber.open(path) as pdf:\n        text = \"\\n\".join(page.extract_text() for page in pdf.pages)\n    return BoardBuilder.from_text(text)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board_builder.BoardBuilder.from_relations","title":"<code>from_relations(relations, false_hypotheses=None)</code>  <code>staticmethod</code>","text":"<p>Build a Board from a list of hypothesis relations and known false hypotheses.</p> Source code in <code>src/ai_minesweeper/board_builder.py</code> <pre><code>@staticmethod\ndef from_relations(\n    relations: list[tuple[str, str]], false_hypotheses: list[str] | None = None\n) -&gt; Board:\n    \"\"\"\n    Build a Board from a list of hypothesis relations and known false hypotheses.\n    \"\"\"\n    false_hypotheses = false_hypotheses or []\n    hypotheses = set(h for relation in relations for h in relation)\n    n = len(hypotheses)\n    n_rows = n_cols = int(n**0.5) + (1 if n**0.5 % 1 else 0)\n\n    board = Board(n_rows, n_cols)\n    hypothesis_map = {}\n\n    # Assign hypotheses to cells\n    for i, hypothesis in enumerate(hypotheses):\n        r, c = divmod(i, n_cols)\n        cell = board.grid[r][c]\n        cell.description = hypothesis\n        cell.is_mine = hypothesis in false_hypotheses\n        hypothesis_map[hypothesis] = (r, c)\n\n    # Define custom neighbors\n    board.custom_neighbors = {}\n    for h1, h2 in relations:\n        r1, c1 = hypothesis_map[h1]\n        r2, c2 = hypothesis_map[h2]\n        board.custom_neighbors.setdefault((r1, c1), []).append((r2, c2))\n        board.custom_neighbors.setdefault((r2, c2), []).append((r1, c1))\n\n    return board\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board_builder.BoardBuilder.from_text","title":"<code>from_text(text)</code>  <code>staticmethod</code>","text":"<p>Parse raw text into a Board object.</p> Source code in <code>src/ai_minesweeper/board_builder.py</code> <pre><code>@staticmethod\ndef from_text(text: str) -&gt; Board:\n    \"\"\"Parse raw text into a Board object.\"\"\"\n    rows = [line.split() for line in text.strip().splitlines()]\n    if not rows or not rows[0]:\n        # Handle empty text by creating a minimal 1x1 board\n        return BoardBuilder._empty_board(1, 1)\n    board = BoardBuilder._empty_board(len(rows), len(rows[0]))\n    BoardBuilder._populate_board(board, rows)\n    return board\n</code></pre>"},{"location":"api/#src.ai_minesweeper.board_builder.BoardBuilder.random_board","title":"<code>random_board(rows, cols, mines)</code>  <code>staticmethod</code>","text":"<p>Generate a random board with the specified dimensions and number of mines.</p> Source code in <code>src/ai_minesweeper/board_builder.py</code> <pre><code>@staticmethod\ndef random_board(rows: int, cols: int, mines: int) -&gt; Board:\n    \"\"\"Generate a random board with the specified dimensions and number of mines.\"\"\"\n    import random\n\n    board = Board(rows, cols)\n    mine_positions = random.sample(range(rows * cols), mines)\n\n    for pos in mine_positions:\n        r, c = divmod(pos, cols)\n        board.grid[r][c].is_mine = True\n\n    for r in range(rows):\n        for c in range(cols):\n            cell = board.grid[r][c]\n            if cell.is_mine:\n                cell.adjacent_mines = -1\n                continue\n            neighbors = board.neighbors(r, c)\n            cell.adjacent_mines = sum(\n                1 for neighbor in neighbors if neighbor.is_mine\n            )\n\n    return board\n</code></pre>"},{"location":"api/#src.ai_minesweeper.ConstraintSolver","title":"<code>ConstraintSolver</code>","text":"Source code in <code>src/ai_minesweeper/constraint_solver.py</code> <pre><code>class ConstraintSolver:\n    @staticmethod\n    def _as_coords(move):\n        return move if isinstance(move, tuple) else (move.row, move.col)\n\n    def _flood_fill(self, board, r, c, revealed):\n        # Classic Minesweeper flood fill: reveal all contiguous zero-value cells and their neighbors\n        stack = [(r, c)]\n        while stack:\n            x, y = stack.pop()\n            if (x, y) in revealed:\n                continue\n            cell = board.grid[x][y]\n            if hasattr(board, \"reveal\"):\n                board.reveal(cell)\n            revealed.add((x, y))\n            if getattr(cell, 'adjacent_mines', None) == 0:\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        nx, ny = x + dx, y + dy\n                        if 0 &lt;= nx &lt; board.n_rows and 0 &lt;= ny &lt; board.n_cols:\n                            ncell = board.grid[nx][ny]\n                            if getattr(ncell, 'state', None).name == 'HIDDEN' and (nx, ny) not in revealed:\n                                stack.append((nx, ny))\n\n    def solve(self, board: Board):\n        \"\"\"\n        Repeatedly choose and reveal moves until the board is solved or no moves remain.\n        Satisfies test interface for ConstraintSolver.solve().\n        \"\"\"\n        moves = []\n        revealed = set()\n        while not board.is_solved():\n            move = self.choose_move(board)\n            if move is None:\n                break\n            r, c = self._as_coords(move)\n            cell = board.grid[r][c]\n            if hasattr(board, \"reveal\"):\n                board.reveal(cell)\n            moves.append((r, c))\n            # Flood fill if value is 0\n            if getattr(cell, 'value', None) == 0:\n                self._flood_fill(board, r, c, revealed)\n        return moves\n    \"\"\"\n    Consolidated constraint solver with meta-cell confidence and \u03c7-recursive optimization.\n\n    Features:\n    - Integrated constraint satisfaction solving\n    - Meta-cell confidence-based decision making\n    - Robust contradiction detection and handling\n    - \u03c7-recursive optimization for complex scenarios\n    - TORUS theory alignment for adaptive learning\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the constraint solver.\"\"\"\n        self.risk_assessor = RiskAssessor()\n        self.confidence_tracker = BetaConfidence()\n        self.policy_wrapper = ConfidencePolicy(self.risk_assessor, self.confidence_tracker)\n\n        # Solver state\n        self.constraints: List[Dict] = []\n        self.solution_cache: Dict[frozenset, Dict] = {}\n        self.contradiction_detected = False\n\n        # \u03c7-recursive state\n        self.solver_iterations = 0\n        self.recursive_depth = 0\n        self.chi_cycle_progress = 0\n\n        self.logger = logging.getLogger(__name__)\n\n    def choose_move(self, board: Board) -&gt; tuple[int, int] | None:\n        \"\"\"\n        Return the next move as a (row, col) tuple, or None if board is solved or no hidden cells.\n        Never returns a Cell. Compatible with all test expectations.\n        \"\"\"\n        import os\n        debug = os.environ.get(\"MINESWEEPER_DEBUG\", \"0\") == \"1\"\n        if board.is_solved():\n            if debug:\n                print(\"[DEBUG] Board is solved. No moves left.\")\n            return None\n        hidden_cells = board.hidden_cells() if hasattr(board, 'hidden_cells') else []\n        if not hidden_cells:\n            if debug:\n                print(\"[DEBUG] No hidden cells left. No moves possible.\")\n            return None\n        if debug:\n            print(f\"[DEBUG] Hidden cells remaining: {len(hidden_cells)}\")\n        result = self.solve_step(board)\n        pos = result.get(\"position\")\n        if pos is None:\n            if debug:\n                print(\"[DEBUG] No move returned by solver.\")\n            return None\n        move_tuple = self._as_coords(pos)\n        if debug:\n            print(f\"[DEBUG] Chosen move: {move_tuple}\")\n        return move_tuple\n\n    def solve_step(self, board: Board) -&gt; Dict:\n        \"\"\"\n        Perform one step of constraint solving with \u03c7-recursive optimization.\n\n        Args:\n            board: Current board state\n\n        Returns:\n            Dictionary with recommended action and analysis\n        \"\"\"\n        self.solver_iterations += 1\n        self.recursive_depth = 0\n\n        # Extract constraints from current board state\n        self.constraints = self._extract_constraints(board)\n\n        # Check for contradictions\n        if self._detect_contradictions():\n            self.contradiction_detected = True\n            return {\n                \"action\": \"contradiction\",\n                \"reason\": \"Board state contains contradictions\",\n                \"confidence\": 0.0\n            }\n\n        self.contradiction_detected = False\n\n        # Try constraint satisfaction solving\n        constraint_solution = self._solve_constraints(board)\n        if constraint_solution[\"action\"] != \"none\":\n            return constraint_solution\n\n        # Fall back to confidence-based policy\n        policy_solution = self.policy_wrapper.get_recommended_action(board)\n\n        # Apply \u03c7-recursive optimization\n        final_solution = self._apply_chi_recursive_optimization(\n            constraint_solution, policy_solution, board\n        )\n\n        # Update \u03c7-cycle progress\n        self._update_chi_cycle(final_solution, board)\n\n        return final_solution\n\n    def _extract_constraints(self, board: Board) -&gt; List[Dict]:\n        \"\"\"\n        Extract minesweeper constraints from current board state.\n        Always normalizes all positions to (row, col) tuples.\n        Args:\n            board: Current board state\n        Returns:\n            List of constraint dictionaries\n        \"\"\"\n        constraints = []\n        # Always get revealed cells as (row, col) tuples\n        revealed_cells = board.get_revealed_cells() if hasattr(board, 'get_revealed_cells') else []\n        positions = [(cell.row, cell.col) if hasattr(cell, 'row') and hasattr(cell, 'col') else tuple(cell) for cell in revealed_cells]\n        for pos in positions:\n            if not (isinstance(pos, tuple) and len(pos) == 2):\n                raise TypeError(f\"Unsupported position type: {type(pos)}\")\n            r, c = pos\n            mine_count = board.revealed_numbers.get((r, c), 0)\n            # Get hidden and flagged neighbors as (row, col) tuples\n            hidden_neighbors = []\n            flagged_neighbors = 0\n            hidden_cells_set = set((cell.row, cell.col) if hasattr(cell, 'row') and hasattr(cell, 'col') else tuple(cell) for cell in board.get_hidden_cells())\n            for nx, ny in board.adjacent_cells(r, c):\n                if (nx, ny) in hidden_cells_set:\n                    hidden_neighbors.append((nx, ny))\n                elif board.cell_states[(nx, ny)] in [CellState.FLAGGED, CellState.SAFE_FLAGGED]:\n                    flagged_neighbors += 1\n            if hidden_neighbors:\n                remaining_mines = mine_count - flagged_neighbors\n                constraints.append({\n                    \"center\": (r, c),\n                    \"hidden_neighbors\": hidden_neighbors,\n                    \"remaining_mines\": remaining_mines,\n                    \"satisfied\": remaining_mines &lt;= 0\n                })\n        self.logger.debug(f\"Extracted {len(constraints)} constraints\")\n        return constraints\n\n    def _detect_contradictions(self) -&gt; bool:\n        \"\"\"\n        Detect contradictions in current constraint set.\n\n        Returns:\n            True if contradictions detected\n        \"\"\"\n        for constraint in self.constraints:\n            remaining_mines = constraint[\"remaining_mines\"]\n            hidden_count = len(constraint[\"hidden_neighbors\"])\n\n            # Impossible constraints\n            if remaining_mines &lt; 0:\n                self.logger.warning(f\"Negative mines constraint at {constraint['center']}\")\n                return True\n\n            if remaining_mines &gt; hidden_count:\n                self.logger.warning(f\"Too many mines constraint at {constraint['center']}\")\n                return True\n\n        # Check for conflicting constraints on same cells\n        cell_constraints = {}\n        for constraint in self.constraints:\n            for cell in constraint[\"hidden_neighbors\"]:\n                if cell not in cell_constraints:\n                    cell_constraints[cell] = []\n                cell_constraints[cell].append(constraint)\n\n        # Advanced contradiction detection would go here\n        # For now, basic checks are sufficient\n\n        return False\n\n    def _solve_constraints(self, board: Board) -&gt; Dict:\n        \"\"\"\n        Solve constraints using logical deduction.\n\n        Args:\n            board: Current board state\n\n        Returns:\n            Dictionary with solution or \"none\" action\n        \"\"\"\n        # Check cache first\n        cache_key = self._create_constraint_cache_key()\n        if cache_key in self.solution_cache:\n            return self.solution_cache[cache_key]\n\n        solution = {\"action\": \"none\"}\n\n        # Simple constraint solving - exact matches\n        for constraint in self.constraints:\n            if constraint[\"satisfied\"]:\n                continue\n\n            remaining_mines = constraint[\"remaining_mines\"]\n            hidden_neighbors = constraint[\"hidden_neighbors\"]\n\n            # All remaining cells are mines\n            if remaining_mines == len(hidden_neighbors) and remaining_mines &gt; 0:\n                pos = hidden_neighbors[0]\n                solution = {\n                    \"action\": \"flag\",\n                    \"position\": pos,\n                    \"confidence\": 0.95,\n                    \"reason\": \"Constraint satisfaction - all remaining cells are mines\"\n                }\n                break\n\n            # No more mines in this constraint\n            if remaining_mines == 0:\n                pos = hidden_neighbors[0]\n                solution = {\n                    \"action\": \"reveal\",\n                    \"position\": pos,\n                    \"confidence\": 0.95,\n                    \"reason\": \"Constraint satisfaction - no mines remaining\"\n                }\n                break\n\n        # Advanced constraint solving with overlapping constraints\n        if solution[\"action\"] == \"none\":\n            solution = self._solve_overlapping_constraints(board)\n\n        # Cache the result\n        self.solution_cache[cache_key] = solution\n\n        return solution\n\n    def _solve_overlapping_constraints(self, board: Board) -&gt; Dict:\n        \"\"\"\n        Solve overlapping constraints using advanced techniques.\n\n        Args:\n            board: Current board state\n\n        Returns:\n            Dictionary with solution or \"none\" action\n        \"\"\"\n        self.recursive_depth += 1\n\n        # Limit recursion for \u03c7-recursive stability\n        if self.recursive_depth &gt; 5:\n            self.recursive_depth -= 1\n            return {\"action\": \"none\"}\n\n        # Find overlapping constraint groups\n        overlap_groups = self._find_constraint_overlaps()\n\n        for group in overlap_groups:\n            # Try to solve each group\n            group_solution = self._solve_constraint_group(group, board)\n            if group_solution[\"action\"] != \"none\":\n                self.recursive_depth -= 1\n                return group_solution\n\n        self.recursive_depth -= 1\n        return {\"action\": \"none\"}\n\n    def _find_constraint_overlaps(self) -&gt; List[List[Dict]]:\n        \"\"\"\n        Find groups of overlapping constraints.\n\n        Returns:\n            List of constraint groups that overlap\n        \"\"\"\n        groups = []\n        processed = set()\n\n        for i, constraint in enumerate(self.constraints):\n            if i in processed:\n                continue\n\n            group = [constraint]\n            group_cells = set(constraint[\"hidden_neighbors\"])\n            processed.add(i)\n\n            # Find overlapping constraints\n            for j, other_constraint in enumerate(self.constraints):\n                if j &lt;= i or j in processed:\n                    continue\n\n                other_cells = set(other_constraint[\"hidden_neighbors\"])\n                if group_cells &amp; other_cells:  # Intersection exists\n                    group.append(other_constraint)\n                    group_cells.update(other_cells)\n                    processed.add(j)\n\n            if len(group) &gt; 1:\n                groups.append(group)\n\n        return groups\n\n    def _solve_constraint_group(self, group: List[Dict], board: Board) -&gt; Dict:\n        \"\"\"\n        Solve a group of overlapping constraints.\n\n        Args:\n            group: List of overlapping constraints\n            board: Current board state\n\n        Returns:\n            Dictionary with solution or \"none\" action\n        \"\"\"\n        # Collect all cells involved in this group\n        all_cells = set()\n        for constraint in group:\n            all_cells.update(constraint[\"hidden_neighbors\"])\n\n        all_cells = list(all_cells)\n\n        # Try different mine distributions\n        total_remaining_mines = sum(c[\"remaining_mines\"] for c in group)\n\n        # Simple case: if total mines equals total cells\n        if total_remaining_mines == len(all_cells):\n            return {\n                \"action\": \"flag\",\n                \"position\": all_cells[0],\n                \"confidence\": 0.9,\n                \"reason\": \"Overlapping constraints - all cells are mines\"\n            }\n\n        if total_remaining_mines == 0:\n            return {\n                \"action\": \"reveal\",\n                \"position\": all_cells[0],\n                \"confidence\": 0.9,\n                \"reason\": \"Overlapping constraints - no mines in group\"\n            }\n\n        # More complex solving would require constraint satisfaction algorithms\n        # For now, return no solution for complex cases\n        return {\"action\": \"none\"}\n\n    def _apply_chi_recursive_optimization(\n        self,\n        constraint_solution: Dict,\n        policy_solution: Dict,\n        board: Board\n    ) -&gt; Dict:\n        \"\"\"\n        Apply \u03c7-recursive optimization to combine solutions.\n\n        Args:\n            constraint_solution: Solution from constraint solving\n            policy_solution: Solution from confidence policy\n            board: Current board state\n\n        Returns:\n            Optimized final solution\n        \"\"\"\n        # Prefer constraint solution if available and high confidence\n        if (constraint_solution[\"action\"] != \"none\" and \n            constraint_solution.get(\"confidence\", 0) &gt; 0.8):\n            return constraint_solution\n\n        # Use policy solution with \u03c7-recursive enhancement\n        if policy_solution[\"action\"] != \"none\":\n            enhanced_solution = policy_solution.copy()\n\n            # Apply \u03c7-recursive confidence boost based on solver history\n            confidence_boost = self._calculate_chi_recursive_boost(board)\n            original_confidence = enhanced_solution.get(\"confidence\", 0.5)\n            enhanced_solution[\"confidence\"] = min(0.95, original_confidence * confidence_boost)\n\n            return enhanced_solution\n\n        return {\"action\": \"none\", \"reason\": \"No viable solution found\"}\n\n    def _calculate_chi_recursive_boost(self, board: Board) -&gt; float:\n        \"\"\"\n        Calculate \u03c7-recursive confidence boost based on solver performance.\n\n        Args:\n            board: Current board state\n\n        Returns:\n            Confidence boost factor\n        \"\"\"\n        # Base boost\n        boost = 1.0\n\n        # Boost based on recent success pattern\n        if len(board.confidence_history) &gt;= 5:\n            recent_avg = sum(board.confidence_history[-5:]) / 5\n            if recent_avg &gt; 0.7:\n                boost *= 1.1  # Recent success\n            elif recent_avg &lt; 0.4:\n                boost *= 0.9  # Recent struggles\n\n        # \u03c7-cycle based adjustment\n        cycle_phase = (self.chi_cycle_progress % 20) / 20.0\n        cycle_boost = 0.95 + 0.1 * np.sin(2 * np.pi * cycle_phase)\n        boost *= cycle_boost\n\n        return boost\n\n    def _update_chi_cycle(self, solution: Dict, board: Board) -&gt; None:\n        \"\"\"\n        Update \u03c7-cycle progress based on solution quality.\n\n        Args:\n            solution: Current solution\n            board: Current board state\n        \"\"\"\n        self.chi_cycle_progress += 1\n\n        # Update board's \u03c7-cycle tracking\n        confidence = solution.get(\"confidence\", 0.5)\n        board.update_chi_cycle(confidence)\n\n    def _create_constraint_cache_key(self) -&gt; frozenset:\n        \"\"\"Create cache key for current constraint set.\"\"\"\n        key_items = []\n        for constraint in self.constraints:\n            center = constraint[\"center\"]\n            neighbors = tuple(sorted(constraint[\"hidden_neighbors\"]))\n            mines = constraint[\"remaining_mines\"]\n            key_items.append((center, neighbors, mines))\n\n        return frozenset(key_items)\n\n    def update_outcome(\n        self, \n        action: str, \n        position: Tuple[int, int], \n        success: bool,\n        board: Board\n    ) -&gt; None:\n        \"\"\"\n        Update solver based on action outcome.\n\n        Args:\n            action: Action taken\n            position: Position of action\n            success: Whether action was successful\n            board: Updated board state\n        \"\"\"\n        # Update confidence tracker\n        outcome_quality = 1.0 if success else 0.0\n        self.policy_wrapper.update_policy_outcome(action, position, success, outcome_quality)\n\n        # Clear cache on state change\n        self.solution_cache.clear()\n        self.risk_assessor.clear_cache()\n\n        self.logger.debug(f\"Solver outcome updated: {action} at {position}, success={success}\")\n\n    def get_solver_statistics(self) -&gt; Dict:\n        \"\"\"\n        Get comprehensive solver statistics.\n\n        Returns:\n            Dictionary with solver performance statistics\n        \"\"\"\n        policy_stats = self.policy_wrapper.get_policy_statistics()\n        risk_stats = self.risk_assessor.get_risk_statistics(None) if hasattr(self, '_last_board') else {}\n\n        return {\n            \"solver_iterations\": self.solver_iterations,\n            \"current_recursive_depth\": self.recursive_depth,\n            \"chi_cycle_progress\": self.chi_cycle_progress,\n            \"contradiction_detected\": self.contradiction_detected,\n            \"active_constraints\": len(self.constraints),\n            \"cache_size\": len(self.solution_cache),\n            \"policy_stats\": policy_stats,\n            \"risk_stats\": risk_stats\n        }\n\n    def reset_solver(self) -&gt; None:\n        \"\"\"Reset solver to initial state.\"\"\"\n        self.constraints.clear()\n        self.solution_cache.clear()\n        self.contradiction_detected = False\n        self.solver_iterations = 0\n        self.recursive_depth = 0\n        self.chi_cycle_progress = 0\n\n        # Reset sub-components\n        self.risk_assessor.clear_cache()\n        self.confidence_tracker.reset_confidence()\n\n        self.logger.info(\"Constraint solver reset to initial state\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.constraint_solver.ConstraintSolver.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the constraint solver.</p> Source code in <code>src/ai_minesweeper/constraint_solver.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the constraint solver.\"\"\"\n    self.risk_assessor = RiskAssessor()\n    self.confidence_tracker = BetaConfidence()\n    self.policy_wrapper = ConfidencePolicy(self.risk_assessor, self.confidence_tracker)\n\n    # Solver state\n    self.constraints: List[Dict] = []\n    self.solution_cache: Dict[frozenset, Dict] = {}\n    self.contradiction_detected = False\n\n    # \u03c7-recursive state\n    self.solver_iterations = 0\n    self.recursive_depth = 0\n    self.chi_cycle_progress = 0\n\n    self.logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.constraint_solver.ConstraintSolver.choose_move","title":"<code>choose_move(board)</code>","text":"<p>Return the next move as a (row, col) tuple, or None if board is solved or no hidden cells. Never returns a Cell. Compatible with all test expectations.</p> Source code in <code>src/ai_minesweeper/constraint_solver.py</code> <pre><code>def choose_move(self, board: Board) -&gt; tuple[int, int] | None:\n    \"\"\"\n    Return the next move as a (row, col) tuple, or None if board is solved or no hidden cells.\n    Never returns a Cell. Compatible with all test expectations.\n    \"\"\"\n    import os\n    debug = os.environ.get(\"MINESWEEPER_DEBUG\", \"0\") == \"1\"\n    if board.is_solved():\n        if debug:\n            print(\"[DEBUG] Board is solved. No moves left.\")\n        return None\n    hidden_cells = board.hidden_cells() if hasattr(board, 'hidden_cells') else []\n    if not hidden_cells:\n        if debug:\n            print(\"[DEBUG] No hidden cells left. No moves possible.\")\n        return None\n    if debug:\n        print(f\"[DEBUG] Hidden cells remaining: {len(hidden_cells)}\")\n    result = self.solve_step(board)\n    pos = result.get(\"position\")\n    if pos is None:\n        if debug:\n            print(\"[DEBUG] No move returned by solver.\")\n        return None\n    move_tuple = self._as_coords(pos)\n    if debug:\n        print(f\"[DEBUG] Chosen move: {move_tuple}\")\n    return move_tuple\n</code></pre>"},{"location":"api/#src.ai_minesweeper.constraint_solver.ConstraintSolver.get_solver_statistics","title":"<code>get_solver_statistics()</code>","text":"<p>Get comprehensive solver statistics.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with solver performance statistics</p> Source code in <code>src/ai_minesweeper/constraint_solver.py</code> <pre><code>def get_solver_statistics(self) -&gt; Dict:\n    \"\"\"\n    Get comprehensive solver statistics.\n\n    Returns:\n        Dictionary with solver performance statistics\n    \"\"\"\n    policy_stats = self.policy_wrapper.get_policy_statistics()\n    risk_stats = self.risk_assessor.get_risk_statistics(None) if hasattr(self, '_last_board') else {}\n\n    return {\n        \"solver_iterations\": self.solver_iterations,\n        \"current_recursive_depth\": self.recursive_depth,\n        \"chi_cycle_progress\": self.chi_cycle_progress,\n        \"contradiction_detected\": self.contradiction_detected,\n        \"active_constraints\": len(self.constraints),\n        \"cache_size\": len(self.solution_cache),\n        \"policy_stats\": policy_stats,\n        \"risk_stats\": risk_stats\n    }\n</code></pre>"},{"location":"api/#src.ai_minesweeper.constraint_solver.ConstraintSolver.reset_solver","title":"<code>reset_solver()</code>","text":"<p>Reset solver to initial state.</p> Source code in <code>src/ai_minesweeper/constraint_solver.py</code> <pre><code>def reset_solver(self) -&gt; None:\n    \"\"\"Reset solver to initial state.\"\"\"\n    self.constraints.clear()\n    self.solution_cache.clear()\n    self.contradiction_detected = False\n    self.solver_iterations = 0\n    self.recursive_depth = 0\n    self.chi_cycle_progress = 0\n\n    # Reset sub-components\n    self.risk_assessor.clear_cache()\n    self.confidence_tracker.reset_confidence()\n\n    self.logger.info(\"Constraint solver reset to initial state\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.constraint_solver.ConstraintSolver.solve","title":"<code>solve(board)</code>","text":"<p>Repeatedly choose and reveal moves until the board is solved or no moves remain. Satisfies test interface for ConstraintSolver.solve().</p> Source code in <code>src/ai_minesweeper/constraint_solver.py</code> <pre><code>def solve(self, board: Board):\n    \"\"\"\n    Repeatedly choose and reveal moves until the board is solved or no moves remain.\n    Satisfies test interface for ConstraintSolver.solve().\n    \"\"\"\n    moves = []\n    revealed = set()\n    while not board.is_solved():\n        move = self.choose_move(board)\n        if move is None:\n            break\n        r, c = self._as_coords(move)\n        cell = board.grid[r][c]\n        if hasattr(board, \"reveal\"):\n            board.reveal(cell)\n        moves.append((r, c))\n        # Flood fill if value is 0\n        if getattr(cell, 'value', None) == 0:\n            self._flood_fill(board, r, c, revealed)\n    return moves\n</code></pre>"},{"location":"api/#src.ai_minesweeper.constraint_solver.ConstraintSolver.solve_step","title":"<code>solve_step(board)</code>","text":"<p>Perform one step of constraint solving with \u03c7-recursive optimization.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Current board state</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with recommended action and analysis</p> Source code in <code>src/ai_minesweeper/constraint_solver.py</code> <pre><code>def solve_step(self, board: Board) -&gt; Dict:\n    \"\"\"\n    Perform one step of constraint solving with \u03c7-recursive optimization.\n\n    Args:\n        board: Current board state\n\n    Returns:\n        Dictionary with recommended action and analysis\n    \"\"\"\n    self.solver_iterations += 1\n    self.recursive_depth = 0\n\n    # Extract constraints from current board state\n    self.constraints = self._extract_constraints(board)\n\n    # Check for contradictions\n    if self._detect_contradictions():\n        self.contradiction_detected = True\n        return {\n            \"action\": \"contradiction\",\n            \"reason\": \"Board state contains contradictions\",\n            \"confidence\": 0.0\n        }\n\n    self.contradiction_detected = False\n\n    # Try constraint satisfaction solving\n    constraint_solution = self._solve_constraints(board)\n    if constraint_solution[\"action\"] != \"none\":\n        return constraint_solution\n\n    # Fall back to confidence-based policy\n    policy_solution = self.policy_wrapper.get_recommended_action(board)\n\n    # Apply \u03c7-recursive optimization\n    final_solution = self._apply_chi_recursive_optimization(\n        constraint_solution, policy_solution, board\n    )\n\n    # Update \u03c7-cycle progress\n    self._update_chi_cycle(final_solution, board)\n\n    return final_solution\n</code></pre>"},{"location":"api/#src.ai_minesweeper.constraint_solver.ConstraintSolver.update_outcome","title":"<code>update_outcome(action, position, success, board)</code>","text":"<p>Update solver based on action outcome.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>Action taken</p> required <code>position</code> <code>Tuple[int, int]</code> <p>Position of action</p> required <code>success</code> <code>bool</code> <p>Whether action was successful</p> required <code>board</code> <code>Board</code> <p>Updated board state</p> required Source code in <code>src/ai_minesweeper/constraint_solver.py</code> <pre><code>def update_outcome(\n    self, \n    action: str, \n    position: Tuple[int, int], \n    success: bool,\n    board: Board\n) -&gt; None:\n    \"\"\"\n    Update solver based on action outcome.\n\n    Args:\n        action: Action taken\n        position: Position of action\n        success: Whether action was successful\n        board: Updated board state\n    \"\"\"\n    # Update confidence tracker\n    outcome_quality = 1.0 if success else 0.0\n    self.policy_wrapper.update_policy_outcome(action, position, success, outcome_quality)\n\n    # Clear cache on state change\n    self.solution_cache.clear()\n    self.risk_assessor.clear_cache()\n\n    self.logger.debug(f\"Solver outcome updated: {action} at {position}, success={success}\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.LegacyBetaConfidence","title":"<code>LegacyBetaConfidence</code>","text":"<p>Bayesian confidence tracker for Minesweeper solver predictions.</p> <p>Maintains a Beta(\u03b1, \u03b2) distribution representing the solver\u2019s calibration. After each move, update \u03b1 (confidence in solver when correct) or \u03b2 (when wrong) to adjust the estimated accuracy. This meta-level state is analogous to TORUS\u2019s controller dimension operator that compensates a ~25.7\u00b0 phase gap to achieve perfect 13\u21920 closure. In our context, it \u201ccloses the loop\u201d between predicted probabilities and actual outcomes.</p> <p>The Beta distribution\u2019s mean (\u03b1/(\u03b1+\u03b2)) serves as the solver\u2019s current confidence level (0 = totally uncalibrated, 1 = perfectly calibrated). A high mean indicates the solver\u2019s predictions have been accurate, whereas a low mean signals systematic errors, prompting more exploratory moves.</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/confidence.py</code> <pre><code>class BetaConfidence:\n    \"\"\"Bayesian confidence tracker for Minesweeper solver predictions.\n\n    Maintains a Beta(\u03b1, \u03b2) distribution representing the solver\u2019s calibration. After\n    each move, update \u03b1 (confidence in solver when correct) or \u03b2 (when wrong) to\n    adjust the estimated accuracy. This meta-level state is analogous to TORUS\u2019s\n    controller dimension operator that compensates a ~25.7\u00b0 phase gap to\n    achieve perfect 13\u21920 closure. In our context, it \u201ccloses the loop\u201d\n    between predicted probabilities and actual outcomes.\n\n    The Beta distribution\u2019s mean (\u03b1/(\u03b1+\u03b2)) serves as the solver\u2019s current confidence\n    level (0 = totally uncalibrated, 1 = perfectly calibrated). A high mean indicates\n    the solver\u2019s predictions have been accurate, whereas a low mean signals\n    systematic errors, prompting more exploratory moves.\n    \"\"\"\n\n    def __init__(self, alpha: float = 1.0, beta: float = 1.0) -&gt; None:\n        \"\"\"Initialize with a prior Beta(\u03b1, \u03b2). Defaults to an uninformative prior (1,1).\"\"\"\n        self.alpha: float = alpha\n        self.beta: float = beta\n        self._threshold: float | None = None  # allow override\n\n    def update(\n        self,\n        predicted_probability: float | None = None,\n        revealed_is_mine: bool | None = None,\n        prob_pred: float | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Update the Beta distribution based on the outcome of a prediction.\n        Increments alpha for correct predictions, beta for incorrect ones.\n\n        Args:\n            predicted_probability: Probability predicted by the solver (for validation only).\n            revealed_is_mine: Boolean indicating if the revealed cell was a mine.\n        \"\"\"\n        # Coalesce probability aliases\n        p = predicted_probability if predicted_probability is not None else prob_pred\n        # Validate inputs\n        if p is None or revealed_is_mine is None:\n            raise ValueError(\"update() requires both a probability and an outcome\")\n        if not (0.0 &lt;= p &lt;= 1.0):\n            raise ValueError(\"probability must be between 0 and 1\")\n        # Simple count update: alpha for correct mine prediction, beta for correct safe prediction\n        if revealed_is_mine:\n            # Correct mine prediction: increment alpha\n            self.alpha += 1.0\n        else:\n            # Correct safe prediction: increment beta, add tiny epsilon if p&gt;=0.5 to slightly penalize 50/50 guesses\n            inc = 1.0 + (1e-6 if p &gt;= 0.5 else 0.0)\n            self.beta += inc\n\n    def mean(self) -&gt; float:\n        \"\"\"Get current confidence level (expected accuracy of solver).\n\n        Returns the mean of the Beta distribution, \\u03b1 / (\\u03b1 + \\u03b2). This represents the\n        solver's estimated probability that its next prediction will be correct. A\n        value near 1 means the solver is well-calibrated (nearly always correct),\n        whereas ~0.5 indicates it's right only about half the time (no better than\n        chance), and lower means it's often wrong.\n\n        This metric allows the solver to modulate its strategy: high confidence \u2192\n        stick to safe moves; low confidence \u2192 take more exploratory risks.\n        \"\"\"\n        if self.alpha + self.beta == 0:\n            return 0.0\n        return self.alpha / (self.alpha + self.beta)\n\n    def set_threshold(self, value: float) -&gt; None:\n        \"\"\"Set a confidence threshold for external use (must be between 0 and 1).\"\"\"\n        if not (0.0 &lt;= value &lt;= 1.0):\n            raise ValueError(\"Threshold must be between 0 and 1\")\n        self._threshold = value\n\n    def get_threshold(self) -&gt; float | None:\n        \"\"\"Get the current confidence threshold (dynamic if not set).\"\"\"\n        if self._threshold is not None:\n            return self._threshold\n        # Dynamic threshold: \u03c4 = 0.25 - 0.20 * mean\n        return 0.25 - 0.20 * self.mean()\n\n    def choose_move(self, board, risk_map: dict) -&gt; Any:\n        \"\"\"\n        Select the next cell to probe based on confidence and risk assessment.\n        \"\"\"\n        tau = self.get_threshold()\n        candidates = [cell for cell, risk in risk_map.items() if risk &lt; tau]\n        if candidates:\n            return min(candidates, key=lambda c: risk_map[c])\n        # fallback: return the minimum risk cell\n        return min(risk_map, key=risk_map.get)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.confidence.BetaConfidence.__init__","title":"<code>__init__(alpha=1.0, beta=1.0)</code>","text":"<p>Initialize with a prior Beta(\u03b1, \u03b2). Defaults to an uninformative prior (1,1).</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/confidence.py</code> <pre><code>def __init__(self, alpha: float = 1.0, beta: float = 1.0) -&gt; None:\n    \"\"\"Initialize with a prior Beta(\u03b1, \u03b2). Defaults to an uninformative prior (1,1).\"\"\"\n    self.alpha: float = alpha\n    self.beta: float = beta\n    self._threshold: float | None = None  # allow override\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.confidence.BetaConfidence.choose_move","title":"<code>choose_move(board, risk_map)</code>","text":"<p>Select the next cell to probe based on confidence and risk assessment.</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/confidence.py</code> <pre><code>def choose_move(self, board, risk_map: dict) -&gt; Any:\n    \"\"\"\n    Select the next cell to probe based on confidence and risk assessment.\n    \"\"\"\n    tau = self.get_threshold()\n    candidates = [cell for cell, risk in risk_map.items() if risk &lt; tau]\n    if candidates:\n        return min(candidates, key=lambda c: risk_map[c])\n    # fallback: return the minimum risk cell\n    return min(risk_map, key=risk_map.get)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.confidence.BetaConfidence.get_threshold","title":"<code>get_threshold()</code>","text":"<p>Get the current confidence threshold (dynamic if not set).</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/confidence.py</code> <pre><code>def get_threshold(self) -&gt; float | None:\n    \"\"\"Get the current confidence threshold (dynamic if not set).\"\"\"\n    if self._threshold is not None:\n        return self._threshold\n    # Dynamic threshold: \u03c4 = 0.25 - 0.20 * mean\n    return 0.25 - 0.20 * self.mean()\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.confidence.BetaConfidence.mean","title":"<code>mean()</code>","text":"<p>Get current confidence level (expected accuracy of solver).</p> <p>Returns the mean of the Beta distribution, \u03b1 / (\u03b1 + \u03b2). This represents the solver's estimated probability that its next prediction will be correct. A value near 1 means the solver is well-calibrated (nearly always correct), whereas ~0.5 indicates it's right only about half the time (no better than chance), and lower means it's often wrong.</p> <p>This metric allows the solver to modulate its strategy: high confidence \u2192 stick to safe moves; low confidence \u2192 take more exploratory risks.</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/confidence.py</code> <pre><code>def mean(self) -&gt; float:\n    \"\"\"Get current confidence level (expected accuracy of solver).\n\n    Returns the mean of the Beta distribution, \\u03b1 / (\\u03b1 + \\u03b2). This represents the\n    solver's estimated probability that its next prediction will be correct. A\n    value near 1 means the solver is well-calibrated (nearly always correct),\n    whereas ~0.5 indicates it's right only about half the time (no better than\n    chance), and lower means it's often wrong.\n\n    This metric allows the solver to modulate its strategy: high confidence \u2192\n    stick to safe moves; low confidence \u2192 take more exploratory risks.\n    \"\"\"\n    if self.alpha + self.beta == 0:\n        return 0.0\n    return self.alpha / (self.alpha + self.beta)\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.confidence.BetaConfidence.set_threshold","title":"<code>set_threshold(value)</code>","text":"<p>Set a confidence threshold for external use (must be between 0 and 1).</p> Source code in <code>src/ai_minesweeper/meta_cell_confidence/confidence.py</code> <pre><code>def set_threshold(self, value: float) -&gt; None:\n    \"\"\"Set a confidence threshold for external use (must be between 0 and 1).\"\"\"\n    if not (0.0 &lt;= value &lt;= 1.0):\n        raise ValueError(\"Threshold must be between 0 and 1\")\n    self._threshold = value\n</code></pre>"},{"location":"api/#src.ai_minesweeper.meta_cell_confidence.confidence.BetaConfidence.update","title":"<code>update(predicted_probability=None, revealed_is_mine=None, prob_pred=None)</code>","text":"<p>Update the Beta distribution based on the outcome of a prediction. Increments alpha for correct predictions, beta for incorrect ones.</p> <p>Parameters:</p> Name Type Description Default <code>predicted_probability</code> <code>float | None</code> <p>Probability predicted by the solver (for validation only).</p> <code>None</code> <code>revealed_is_mine</code> <code>bool | None</code> <p>Boolean indicating if the revealed cell was a mine.</p> <code>None</code> Source code in <code>src/ai_minesweeper/meta_cell_confidence/confidence.py</code> <pre><code>def update(\n    self,\n    predicted_probability: float | None = None,\n    revealed_is_mine: bool | None = None,\n    prob_pred: float | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the Beta distribution based on the outcome of a prediction.\n    Increments alpha for correct predictions, beta for incorrect ones.\n\n    Args:\n        predicted_probability: Probability predicted by the solver (for validation only).\n        revealed_is_mine: Boolean indicating if the revealed cell was a mine.\n    \"\"\"\n    # Coalesce probability aliases\n    p = predicted_probability if predicted_probability is not None else prob_pred\n    # Validate inputs\n    if p is None or revealed_is_mine is None:\n        raise ValueError(\"update() requires both a probability and an outcome\")\n    if not (0.0 &lt;= p &lt;= 1.0):\n        raise ValueError(\"probability must be between 0 and 1\")\n    # Simple count update: alpha for correct mine prediction, beta for correct safe prediction\n    if revealed_is_mine:\n        # Correct mine prediction: increment alpha\n        self.alpha += 1.0\n    else:\n        # Correct safe prediction: increment beta, add tiny epsilon if p&gt;=0.5 to slightly penalize 50/50 guesses\n        inc = 1.0 + (1e-6 if p &gt;= 0.5 else 0.0)\n        self.beta += inc\n</code></pre>"},{"location":"api/#src.ai_minesweeper.RiskAssessor","title":"<code>RiskAssessor</code>","text":"Source code in <code>src/ai_minesweeper/risk_assessor.py</code> <pre><code>class RiskAssessor:\n    @staticmethod\n    def _as_coords(move):\n        return move if isinstance(move, tuple) else (move.row, move.col)\n    # Removed classmethod recursion. See instance method below.\n    \"\"\"\n    Risk assessment engine for minesweeper AI with \u03c7-recursive capabilities.\n\n    Features:\n    - Returns risk maps with coordinate keys for test consistency\n    - Dynamic risk calculation based on revealed information\n    - Integration with \u03c7-recursive decision making\n    - TORUS theory alignment for confidence feedback\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the risk assessor.\"\"\"\n        self.logger = logging.getLogger(__name__)\n        self.risk_cache: Dict[frozenset, Dict[Tuple[int, int], float]] = {}\n        self.chi_recursive_depth = 0\n\n    def calculate_risk_map(self, board: Board) -&gt; Dict[Tuple[int, int], float]:\n        \"\"\"\n        Calculate risk map with coordinate keys for all hidden cells.\n\n        Args:\n            board: Current board state\n\n        Returns:\n            Dictionary mapping coordinates to risk values [0.0, 1.0]\n        \"\"\"\n        risk_map = {}\n        hidden_cells = board.get_hidden_cells()\n\n        if not hidden_cells:\n            return risk_map\n\n        # Create cache key from board state\n        cache_key = self._create_cache_key(board)\n        if cache_key in self.risk_cache:\n            self.logger.debug(\"Using cached risk calculation\")\n            return self.risk_cache[cache_key]\n\n        # Calculate base risk for each hidden cell\n        for cell in hidden_cells:\n            coords = (cell.row, cell.col)\n            risk = self._calculate_cell_risk(coords, board)\n            risk_map[coords] = float(risk)\n\n        # Apply \u03c7-recursive refinement\n        risk_map = self._apply_chi_recursive_refinement(risk_map, board)\n\n        # Inject jitter if all risks are equal (variance for no-clue scenario)\n        import random\n        values = list(risk_map.values())\n        if len(set(values)) &lt;= 1 and len(values) &gt; 1:\n            for k in risk_map:\n                risk_map[k] += random.uniform(-0.01, 0.01)\n            # Normalize\n            total = sum(risk_map.values())\n            if total &gt; 0:\n                risk_map = {k: v / total for k, v in risk_map.items()}\n\n        # Cache the result\n        self.risk_cache[cache_key] = risk_map\n\n        self.logger.debug(f\"Risk map calculated for {len(hidden_cells)} hidden cells\")\n        return risk_map\n\n    def _create_cache_key(self, board: Board) -&gt; frozenset:\n        \"\"\"Create a cache key from board state.\"\"\"\n        state_items = []\n\n        # Add revealed cells with their numbers\n        for pos, state in board.cell_states.items():\n            if state == CellState.REVEALED:\n                number = board.revealed_numbers.get(pos, 0)\n                state_items.append((pos, 'revealed', number))\n            elif state in [CellState.FLAGGED, CellState.SAFE_FLAGGED]:\n                state_items.append((pos, 'flagged'))\n\n        return frozenset(state_items)\n\n    def _calculate_cell_risk(self, cell: Tuple[int, int], board: Board) -&gt; float:\n        \"\"\"\n        Calculate risk for a single cell based on neighboring constraints.\n\n        Args:\n            cell: Cell coordinates\n            board: Current board state\n\n        Returns:\n            Risk value between 0.0 and 1.0\n        \"\"\"\n        x, y = cell\n        total_risk = 0.0\n        constraint_count = 0\n\n        # Check all revealed neighbors for constraints\n        for nx, ny in board.adjacent_cells(x, y):\n            if (nx, ny) in board.get_revealed_cells():\n                revealed_number = board.revealed_numbers[(nx, ny)]\n                neighbor_risk = self._calculate_neighbor_constraint_risk(\n                    (nx, ny), revealed_number, cell, board\n                )\n                total_risk += neighbor_risk\n                constraint_count += 1\n\n        # Base risk from global mine density\n        if constraint_count == 0:\n            # Use Board.mines_remaining property for global density\n            base_risk = board.mines_remaining / len(board.get_hidden_cells())\n            return min(base_risk, 1.0)\n\n        # Average constraint risk\n        avg_risk = total_risk / constraint_count\n\n        # Apply TORUS theory dampening for \u03c7-recursive stability\n        dampening_factor = 1.0 - (0.1 * board.chi_cycle_count / 100)\n        dampening_factor = max(0.5, min(1.0, dampening_factor))\n\n        return min(avg_risk * dampening_factor, 1.0)\n\n    def _calculate_neighbor_constraint_risk(\n        self, \n        neighbor_pos: Tuple[int, int], \n        revealed_number: int,\n        target_cell: Tuple[int, int], \n        board: Board\n    ) -&gt; float:\n        \"\"\"\n        Calculate risk contribution from a revealed neighbor's constraint.\n\n        Args:\n            neighbor_pos: Position of revealed neighbor\n            revealed_number: Number shown on revealed neighbor\n            target_cell: Cell we're calculating risk for\n            board: Current board state\n\n        Returns:\n            Risk contribution from this constraint\n        \"\"\"\n        nx, ny = neighbor_pos\n\n        # Get all hidden neighbors of this revealed cell\n        hidden_neighbors = []\n        flagged_neighbors = 0\n\n        for nnx, nny in board.adjacent_cells(nx, ny):\n            if (nnx, nny) in board.get_hidden_cells():\n                hidden_neighbors.append((nnx, nny))\n            elif board.cell_states[(nnx, nny)] in [CellState.FLAGGED, CellState.SAFE_FLAGGED]:\n                flagged_neighbors += 1\n\n        # Calculate remaining mines needed for this constraint\n        remaining_mines_needed = revealed_number - flagged_neighbors\n\n        if remaining_mines_needed &lt;= 0:\n            # All mines already found for this constraint\n            return 0.0\n\n        if len(hidden_neighbors) == 0:\n            # No hidden neighbors but mines still needed - inconsistent state\n            return 1.0\n\n        if target_cell not in hidden_neighbors:\n            # Target cell not constrained by this neighbor\n            return 0.0\n\n        # Simple probability: remaining mines / remaining hidden cells\n        base_probability = remaining_mines_needed / len(hidden_neighbors)\n\n        # \u03c7-recursive adjustment based on constraint satisfaction\n        chi_adjustment = self._calculate_chi_recursive_adjustment(\n            neighbor_pos, hidden_neighbors, board\n        )\n\n        return min(base_probability * chi_adjustment, 1.0)\n\n    def _calculate_chi_recursive_adjustment(\n        self,\n        constraint_pos: Tuple[int, int],\n        hidden_neighbors: List[Tuple[int, int]],\n        board: Board\n    ) -&gt; float:\n        \"\"\"\n        Calculate \u03c7-recursive adjustment factor for constraint risk.\n\n        Args:\n            constraint_pos: Position of constraining cell\n            hidden_neighbors: Hidden neighbors of constraint\n            board: Current board state\n\n        Returns:\n            Adjustment factor for \u03c7-recursive feedback\n        \"\"\"\n        self.chi_recursive_depth += 1\n\n        # Limit recursion depth for stability\n        if self.chi_recursive_depth &gt; 3:\n            self.chi_recursive_depth -= 1\n            return 1.0\n\n        # Calculate feedback from confidence history\n        if len(board.confidence_history) &gt; 5:\n            recent_confidence = sum(board.confidence_history[-5:]) / 5\n\n            # High confidence increases precision (lower adjustment)\n            # Low confidence increases caution (higher adjustment)\n            confidence_factor = 2.0 - recent_confidence\n        else:\n            confidence_factor = 1.0\n\n        # TORUS theory integration - cyclical adjustment\n        torus_cycle = (board.chi_cycle_count % 10) / 10.0\n        torus_adjustment = 0.9 + 0.2 * np.sin(2 * np.pi * torus_cycle)\n\n        self.chi_recursive_depth -= 1\n        return confidence_factor * torus_adjustment\n\n    def _apply_chi_recursive_refinement(\n        self, \n        risk_map: Dict[Tuple[int, int], float], \n        board: Board\n    ) -&gt; Dict[Tuple[int, int], float]:\n        \"\"\"\n        Apply \u03c7-recursive refinement to risk map for improved accuracy.\n\n        Args:\n            risk_map: Initial risk map\n            board: Current board state\n\n        Returns:\n            Refined risk map with \u03c7-recursive adjustments\n        \"\"\"\n        refined_map = risk_map.copy()\n\n        # Sort cells by risk for \u03c7-recursive processing\n        sorted_cells = sorted(risk_map.items(), key=lambda x: x[1], reverse=True)\n\n        # Apply refinement in risk order\n        for cell, risk in sorted_cells:\n            # Accept both tuple and Cell keys\n            if hasattr(cell, \"row\") and hasattr(cell, \"col\"):\n                row, col = cell.row, cell.col\n            elif isinstance(cell, tuple) and len(cell) == 2:\n                row, col = cell\n            else:\n                continue\n            # Check for local consistency with high-risk neighbors\n            neighbor_risks = []\n            for nx, ny in board.adjacent_cells(row, col):\n                # Accept both Cell and tuple keys in refined_map\n                for k in [ (nx, ny), getattr(board.grid[nx][ny], 'row', None) is not None and board.grid[nx][ny] or None ]:\n                    if k in refined_map:\n                        neighbor_risks.append(refined_map[k])\n                        break\n            if neighbor_risks:\n                # \u03c7-recursive smoothing - balance local vs global risk\n                local_avg = sum(neighbor_risks) / len(neighbor_risks)\n                global_risk = risk\n                # Weighted combination favoring global at high risk\n                weight = risk  # Higher risk = more global influence\n                refined_risk = weight * global_risk + (1 - weight) * local_avg\n                refined_map[cell] = min(refined_risk, 1.0)\n        return refined_map\n\n    def get_safest_cells(\n        self, \n        board: Board, \n        count: int = 1\n    ) -&gt; List[Tuple[int, int]]:\n        \"\"\"\n        Get the safest cells to reveal based on risk assessment.\n\n        Args:\n            board: Current board state\n            count: Number of safest cells to return\n\n        Returns:\n            List of safest cell coordinates\n        \"\"\"\n        risk_map = self.calculate_risk_map(board)\n\n        if not risk_map:\n            return []\n\n        # Sort by risk (ascending - lowest risk first)\n        sorted_cells = sorted(risk_map.items(), key=lambda x: x[1])\n\n        # Return the requested number of safest cells\n        safest = [cell for cell, risk in sorted_cells[:count]]\n\n        self.logger.debug(f\"Identified {len(safest)} safest cells\")\n        return safest\n\n    def get_highest_risk_cells(\n        self, \n        board: Board, \n        threshold: float = 0.8,\n        count: int = None\n    ) -&gt; List[Tuple[int, int]]:\n        \"\"\"\n        Get cells with highest mine risk for flagging.\n\n        Args:\n            board: Current board state\n            threshold: Minimum risk threshold for flagging\n            count: Maximum number of cells to return (None for all above threshold)\n\n        Returns:\n            List of high-risk cell coordinates\n        \"\"\"\n        risk_map = self.calculate_risk_map(board)\n\n        # Filter by threshold\n        high_risk_cells = [\n            cell for cell, risk in risk_map.items() \n            if risk &gt;= threshold\n        ]\n\n        # Sort by risk (descending - highest risk first)\n        high_risk_cells.sort(key=lambda cell: risk_map[cell], reverse=True)\n\n        # Limit count if specified\n        if count is not None:\n            high_risk_cells = high_risk_cells[:count]\n\n        self.logger.debug(f\"Identified {len(high_risk_cells)} high-risk cells above {threshold}\")\n        return high_risk_cells\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear the risk calculation cache.\"\"\"\n        self.risk_cache.clear()\n        self.logger.debug(\"Risk cache cleared\")\n\n    def get_risk_statistics(self, board: Board) -&gt; Dict:\n        \"\"\"\n        Get statistical summary of current risk assessment.\n\n        Args:\n            board: Current board state\n\n        Returns:\n            Dictionary with risk statistics\n        \"\"\"\n        risk_map = self.calculate_risk_map(board)\n\n        if not risk_map:\n            return {\"error\": \"No hidden cells to assess\"}\n\n        risks = list(risk_map.values())\n\n        return {\n            \"total_cells\": len(risks),\n            \"min_risk\": min(risks),\n            \"max_risk\": max(risks),\n            \"mean_risk\": sum(risks) / len(risks),\n            \"std_risk\": np.std(risks),\n            \"safe_cells\": len([r for r in risks if r &lt; 0.2]),\n            \"dangerous_cells\": len([r for r in risks if r &gt; 0.8]),\n            \"chi_recursive_depth\": self.chi_recursive_depth,\n            \"cache_size\": len(self.risk_cache)\n        }\n\n\n    def estimate(self, board: Board) -&gt; Dict[tuple, float]:\n        \"\"\"\n        Estimate risk for all hidden cells on the board.\n        :param board: Current board state.\n        :return: Dictionary mapping (row, col) tuples to risk values.\n        \"\"\"\n        import random\n        # Robust hidden cell extraction for mocks and real boards\n        if hasattr(board, \"grid\"):\n            hidden_cells = [cell for row in board.grid for cell in row if board.is_hidden(cell)]\n        elif hasattr(board, \"hidden_cells\"):\n            hidden_cells = board.hidden_cells()\n        elif hasattr(board, \"get_hidden_cells\"):\n            hidden_cells = board.get_hidden_cells()\n        else:\n            hidden_cells = []\n        if not hidden_cells:\n            return {}\n\n        risk_map = {}\n        for cell in hidden_cells:\n            coords = (cell.row, cell.col)\n            risk = self._calculate_cell_risk(coords, board)\n            if risk is None or not isinstance(risk, (int, float)) or (isinstance(risk, float) and (risk != risk or risk is None)):\n                risk = 1.0\n            risk_map[coords] = float(risk)\n        # Add jitter for variance if all risks are equal or clues are missing\n        values = list(risk_map.values())\n        if len(set(values)) &lt;= 1 and len(values) &gt; 1:\n            for k in risk_map:\n                risk_map[k] += random.uniform(-0.01, 0.01)\n        # Normalize\n        total = sum(risk_map.values())\n        if total &gt; 0:\n            risk_map = {k: v / total for k, v in risk_map.items()}\n        # Sanitize after normalization: coerce None/non-numeric to 1.0\n        for k in risk_map:\n            if risk_map[k] is None or not isinstance(risk_map[k], (int, float)):\n                risk_map[k] = 1.0\n        return risk_map\n\n        # Add small random noise if all risks are equal (to avoid uniformity)\n        values = list(risk_map.values())\n        if len(set(values)) &lt;= 1 and len(values) &gt; 1:\n            for k in risk_map:\n                risk_map[k] += random.uniform(-1e-6, 1e-6)\n\n        # Normalize probabilities\n        total = sum(float(risk_map[k]) for k in risk_map if isinstance(risk_map[k], (int, float)))\n        if total &gt; 0:\n            for k in risk_map:\n                risk_map[k] = float(risk_map[k]) / total\n        return risk_map\n\n    def choose_move(self, board: Board, return_tuple: bool = True) -&gt; Cell | tuple | None:\n        \"\"\"\n        Choose the cell with the lowest estimated risk.\n        Returns a (row, col) tuple by default, or Cell if return_tuple=False.\n        Returns None if no moves.\n        \"\"\"\n        risk_map = self.estimate(board)\n        # Sanitize after normalization\n        for k in risk_map:\n            if risk_map[k] is None or not isinstance(risk_map[k], (int, float)):\n                risk_map[k] = 1.0\n        if not risk_map:\n            return None\n        best_key = min(risk_map, key=risk_map.get)\n        r, c = self._as_coords(best_key)\n        if return_tuple:\n            return (r, c)\n        if hasattr(board, \"grid\"):\n            return board.grid[r][c]\n        return best_key\n</code></pre>"},{"location":"api/#src.ai_minesweeper.risk_assessor.RiskAssessor.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the risk assessor.</p> Source code in <code>src/ai_minesweeper/risk_assessor.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the risk assessor.\"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.risk_cache: Dict[frozenset, Dict[Tuple[int, int], float]] = {}\n    self.chi_recursive_depth = 0\n</code></pre>"},{"location":"api/#src.ai_minesweeper.risk_assessor.RiskAssessor.calculate_risk_map","title":"<code>calculate_risk_map(board)</code>","text":"<p>Calculate risk map with coordinate keys for all hidden cells.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Current board state</p> required <p>Returns:</p> Type Description <code>Dict[Tuple[int, int], float]</code> <p>Dictionary mapping coordinates to risk values [0.0, 1.0]</p> Source code in <code>src/ai_minesweeper/risk_assessor.py</code> <pre><code>def calculate_risk_map(self, board: Board) -&gt; Dict[Tuple[int, int], float]:\n    \"\"\"\n    Calculate risk map with coordinate keys for all hidden cells.\n\n    Args:\n        board: Current board state\n\n    Returns:\n        Dictionary mapping coordinates to risk values [0.0, 1.0]\n    \"\"\"\n    risk_map = {}\n    hidden_cells = board.get_hidden_cells()\n\n    if not hidden_cells:\n        return risk_map\n\n    # Create cache key from board state\n    cache_key = self._create_cache_key(board)\n    if cache_key in self.risk_cache:\n        self.logger.debug(\"Using cached risk calculation\")\n        return self.risk_cache[cache_key]\n\n    # Calculate base risk for each hidden cell\n    for cell in hidden_cells:\n        coords = (cell.row, cell.col)\n        risk = self._calculate_cell_risk(coords, board)\n        risk_map[coords] = float(risk)\n\n    # Apply \u03c7-recursive refinement\n    risk_map = self._apply_chi_recursive_refinement(risk_map, board)\n\n    # Inject jitter if all risks are equal (variance for no-clue scenario)\n    import random\n    values = list(risk_map.values())\n    if len(set(values)) &lt;= 1 and len(values) &gt; 1:\n        for k in risk_map:\n            risk_map[k] += random.uniform(-0.01, 0.01)\n        # Normalize\n        total = sum(risk_map.values())\n        if total &gt; 0:\n            risk_map = {k: v / total for k, v in risk_map.items()}\n\n    # Cache the result\n    self.risk_cache[cache_key] = risk_map\n\n    self.logger.debug(f\"Risk map calculated for {len(hidden_cells)} hidden cells\")\n    return risk_map\n</code></pre>"},{"location":"api/#src.ai_minesweeper.risk_assessor.RiskAssessor.choose_move","title":"<code>choose_move(board, return_tuple=True)</code>","text":"<p>Choose the cell with the lowest estimated risk. Returns a (row, col) tuple by default, or Cell if return_tuple=False. Returns None if no moves.</p> Source code in <code>src/ai_minesweeper/risk_assessor.py</code> <pre><code>def choose_move(self, board: Board, return_tuple: bool = True) -&gt; Cell | tuple | None:\n    \"\"\"\n    Choose the cell with the lowest estimated risk.\n    Returns a (row, col) tuple by default, or Cell if return_tuple=False.\n    Returns None if no moves.\n    \"\"\"\n    risk_map = self.estimate(board)\n    # Sanitize after normalization\n    for k in risk_map:\n        if risk_map[k] is None or not isinstance(risk_map[k], (int, float)):\n            risk_map[k] = 1.0\n    if not risk_map:\n        return None\n    best_key = min(risk_map, key=risk_map.get)\n    r, c = self._as_coords(best_key)\n    if return_tuple:\n        return (r, c)\n    if hasattr(board, \"grid\"):\n        return board.grid[r][c]\n    return best_key\n</code></pre>"},{"location":"api/#src.ai_minesweeper.risk_assessor.RiskAssessor.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the risk calculation cache.</p> Source code in <code>src/ai_minesweeper/risk_assessor.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear the risk calculation cache.\"\"\"\n    self.risk_cache.clear()\n    self.logger.debug(\"Risk cache cleared\")\n</code></pre>"},{"location":"api/#src.ai_minesweeper.risk_assessor.RiskAssessor.estimate","title":"<code>estimate(board)</code>","text":"<p>Estimate risk for all hidden cells on the board. :param board: Current board state. :return: Dictionary mapping (row, col) tuples to risk values.</p> Source code in <code>src/ai_minesweeper/risk_assessor.py</code> <pre><code>def estimate(self, board: Board) -&gt; Dict[tuple, float]:\n    \"\"\"\n    Estimate risk for all hidden cells on the board.\n    :param board: Current board state.\n    :return: Dictionary mapping (row, col) tuples to risk values.\n    \"\"\"\n    import random\n    # Robust hidden cell extraction for mocks and real boards\n    if hasattr(board, \"grid\"):\n        hidden_cells = [cell for row in board.grid for cell in row if board.is_hidden(cell)]\n    elif hasattr(board, \"hidden_cells\"):\n        hidden_cells = board.hidden_cells()\n    elif hasattr(board, \"get_hidden_cells\"):\n        hidden_cells = board.get_hidden_cells()\n    else:\n        hidden_cells = []\n    if not hidden_cells:\n        return {}\n\n    risk_map = {}\n    for cell in hidden_cells:\n        coords = (cell.row, cell.col)\n        risk = self._calculate_cell_risk(coords, board)\n        if risk is None or not isinstance(risk, (int, float)) or (isinstance(risk, float) and (risk != risk or risk is None)):\n            risk = 1.0\n        risk_map[coords] = float(risk)\n    # Add jitter for variance if all risks are equal or clues are missing\n    values = list(risk_map.values())\n    if len(set(values)) &lt;= 1 and len(values) &gt; 1:\n        for k in risk_map:\n            risk_map[k] += random.uniform(-0.01, 0.01)\n    # Normalize\n    total = sum(risk_map.values())\n    if total &gt; 0:\n        risk_map = {k: v / total for k, v in risk_map.items()}\n    # Sanitize after normalization: coerce None/non-numeric to 1.0\n    for k in risk_map:\n        if risk_map[k] is None or not isinstance(risk_map[k], (int, float)):\n            risk_map[k] = 1.0\n    return risk_map\n\n    # Add small random noise if all risks are equal (to avoid uniformity)\n    values = list(risk_map.values())\n    if len(set(values)) &lt;= 1 and len(values) &gt; 1:\n        for k in risk_map:\n            risk_map[k] += random.uniform(-1e-6, 1e-6)\n\n    # Normalize probabilities\n    total = sum(float(risk_map[k]) for k in risk_map if isinstance(risk_map[k], (int, float)))\n    if total &gt; 0:\n        for k in risk_map:\n            risk_map[k] = float(risk_map[k]) / total\n    return risk_map\n</code></pre>"},{"location":"api/#src.ai_minesweeper.risk_assessor.RiskAssessor.get_highest_risk_cells","title":"<code>get_highest_risk_cells(board, threshold=0.8, count=None)</code>","text":"<p>Get cells with highest mine risk for flagging.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Current board state</p> required <code>threshold</code> <code>float</code> <p>Minimum risk threshold for flagging</p> <code>0.8</code> <code>count</code> <code>int</code> <p>Maximum number of cells to return (None for all above threshold)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Tuple[int, int]]</code> <p>List of high-risk cell coordinates</p> Source code in <code>src/ai_minesweeper/risk_assessor.py</code> <pre><code>def get_highest_risk_cells(\n    self, \n    board: Board, \n    threshold: float = 0.8,\n    count: int = None\n) -&gt; List[Tuple[int, int]]:\n    \"\"\"\n    Get cells with highest mine risk for flagging.\n\n    Args:\n        board: Current board state\n        threshold: Minimum risk threshold for flagging\n        count: Maximum number of cells to return (None for all above threshold)\n\n    Returns:\n        List of high-risk cell coordinates\n    \"\"\"\n    risk_map = self.calculate_risk_map(board)\n\n    # Filter by threshold\n    high_risk_cells = [\n        cell for cell, risk in risk_map.items() \n        if risk &gt;= threshold\n    ]\n\n    # Sort by risk (descending - highest risk first)\n    high_risk_cells.sort(key=lambda cell: risk_map[cell], reverse=True)\n\n    # Limit count if specified\n    if count is not None:\n        high_risk_cells = high_risk_cells[:count]\n\n    self.logger.debug(f\"Identified {len(high_risk_cells)} high-risk cells above {threshold}\")\n    return high_risk_cells\n</code></pre>"},{"location":"api/#src.ai_minesweeper.risk_assessor.RiskAssessor.get_risk_statistics","title":"<code>get_risk_statistics(board)</code>","text":"<p>Get statistical summary of current risk assessment.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Current board state</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with risk statistics</p> Source code in <code>src/ai_minesweeper/risk_assessor.py</code> <pre><code>def get_risk_statistics(self, board: Board) -&gt; Dict:\n    \"\"\"\n    Get statistical summary of current risk assessment.\n\n    Args:\n        board: Current board state\n\n    Returns:\n        Dictionary with risk statistics\n    \"\"\"\n    risk_map = self.calculate_risk_map(board)\n\n    if not risk_map:\n        return {\"error\": \"No hidden cells to assess\"}\n\n    risks = list(risk_map.values())\n\n    return {\n        \"total_cells\": len(risks),\n        \"min_risk\": min(risks),\n        \"max_risk\": max(risks),\n        \"mean_risk\": sum(risks) / len(risks),\n        \"std_risk\": np.std(risks),\n        \"safe_cells\": len([r for r in risks if r &lt; 0.2]),\n        \"dangerous_cells\": len([r for r in risks if r &gt; 0.8]),\n        \"chi_recursive_depth\": self.chi_recursive_depth,\n        \"cache_size\": len(self.risk_cache)\n    }\n</code></pre>"},{"location":"api/#src.ai_minesweeper.risk_assessor.RiskAssessor.get_safest_cells","title":"<code>get_safest_cells(board, count=1)</code>","text":"<p>Get the safest cells to reveal based on risk assessment.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Current board state</p> required <code>count</code> <code>int</code> <p>Number of safest cells to return</p> <code>1</code> <p>Returns:</p> Type Description <code>List[Tuple[int, int]]</code> <p>List of safest cell coordinates</p> Source code in <code>src/ai_minesweeper/risk_assessor.py</code> <pre><code>def get_safest_cells(\n    self, \n    board: Board, \n    count: int = 1\n) -&gt; List[Tuple[int, int]]:\n    \"\"\"\n    Get the safest cells to reveal based on risk assessment.\n\n    Args:\n        board: Current board state\n        count: Number of safest cells to return\n\n    Returns:\n        List of safest cell coordinates\n    \"\"\"\n    risk_map = self.calculate_risk_map(board)\n\n    if not risk_map:\n        return []\n\n    # Sort by risk (ascending - lowest risk first)\n    sorted_cells = sorted(risk_map.items(), key=lambda x: x[1])\n\n    # Return the requested number of safest cells\n    safest = [cell for cell, risk in sorted_cells[:count]]\n\n    self.logger.debug(f\"Identified {len(safest)} safest cells\")\n    return safest\n</code></pre>"},{"location":"bicycle_validation/","title":"Bicycle Ghost-Rider Validation","text":"<p>Dynamic stabilization in bicycle ghost-rider simulations mirrors controller dimension theory.</p>"},{"location":"bicycle_validation/#key-findings","title":"Key Findings","text":"<ul> <li>Controller dimension principles validated through simulations.</li> <li>Empirical evidence supports theoretical predictions.</li> </ul> <p>For detailed results, refer to the validation report.</p>"},{"location":"ci_setup/","title":"GitHub Actions &amp; Security Setup","text":"Secret Where to add Scope <code>CODECOV_TOKEN</code> Settings \u2192 Secrets \u2192 Actions repository <ol> <li> <p>Go to Settings \u2192 Actions \u2192 General and set:    \u2022 Workflow permissions \u2192 Read and write permissions \u2714    \u2022 Allow GitHub Actions to create and approve pull requests (optional).</p> </li> <li> <p>If self-hosted runners are used, ensure they have the correct labels and are online.</p> </li> </ol> <p>Workflows will fail fast with a clear error if <code>CODECOV_TOKEN</code> is absent.</p>"},{"location":"citation_map/","title":"Citation Map","text":"Code Folder TORUS Supplement Section <code>src/ai_minesweeper/</code> Sec. 3.3: \u03c7-Cycle Recursion <code>src/ai_minesweeper/meta_cell_confidence/</code> Sec. 4.1: Controller Dimension <code>examples/</code> Sec. 5.2: Empirical Tests <code>docs/</code> Sec. 6.1: Theory Overview"},{"location":"confidence_osc/","title":"Confidence Oscillation","text":"<p>Visualize the damped \u03c7-wave fit to solver confidence history. The chart below demonstrates the \u03c4 effect, where \u03c4 represents the decay constant of the oscillation, indicating how quickly the confidence stabilizes over time.</p> <p></p> <p>Parameters: - Amplitude: Initial confidence level. - Decay rate (\u03c4): Rate at which confidence stabilizes. - Period: Time between oscillation peaks.</p> <p>The \u03c4 parameter controls how exploratory the confidence policy becomes. Higher \u03c4 spreads probability mass and encourages more exploratory selections.</p> <p>The \u03c4 effect is critical for understanding solver calibration and risk tolerance adjustments in dynamic environments.</p>"},{"location":"contributor_guide/","title":"Contributor Guide","text":""},{"location":"contributor_guide/#extending-torus-brot","title":"Extending TORUS-brot","text":"<ul> <li>Experiment with higher-order fractals or link with external fractal libraries.</li> <li>Explore mini \"satellite\" copies and measure their scaling to compare with Feigenbaum\u2019s delta for \u03c7-cycle.</li> <li>Introduce random variations each iteration to mimic observer effects and analyze fractal boundary deformation.</li> </ul>"},{"location":"contributor_guide/#improving-meta-cell","title":"Improving Meta-Cell","text":"<ul> <li>Implement more sophisticated Bayesian updates or alternative risk strategies.</li> <li>Enhance confidence visualization with historical trends or interactive charts.</li> <li>Optimize solver integration for larger boards or complex domains.</li> </ul>"},{"location":"contributor_guide/#general-contribution-tips","title":"General Contribution Tips","text":"<ul> <li>Follow the modular design principles outlined in the README.</li> <li>Ensure all new features are documented and tested.</li> <li>Run <code>pytest</code> to verify that all tests pass before submitting a pull request.</li> </ul>"},{"location":"design_meta_cell/","title":"Meta-Cell Confidence Module","text":""},{"location":"design_meta_cell/#overview","title":"Overview","text":"<p>The Meta-Cell Confidence Module introduces a feedback loop to dynamically adjust the hypothesis solver's risk tolerance based on its prediction accuracy. Inspired by TORUS Theory's controller dimension, this module ensures the solver maintains a balanced strategy between exploration and exploitation.</p>"},{"location":"design_meta_cell/#rationale","title":"Rationale","text":"<p>The Meta-Cell Confidence Module dynamically adjusts risk tolerance based on solver accuracy. Using a Beta distribution, it tracks success rates and tunes the solver's behavior.</p>"},{"location":"design_meta_cell/#betaconfidence-class","title":"BetaConfidence Class","text":"<p>Tracks solver confidence using a Beta distribution. Updates confidence based on prediction accuracy using the Brier score.</p>"},{"location":"design_meta_cell/#confidencepolicy-class","title":"ConfidencePolicy Class","text":"<p>Wraps the base solver to adjust move selection based on confidence. Implements a risk threshold that varies with confidence level.</p>"},{"location":"design_meta_cell/#visualization","title":"Visualization","text":"<p>Displays confidence in GUI (Streamlit) or CLI mode, providing real-time feedback on solver calibration.</p>"},{"location":"design_meta_cell/#expected-outcomes","title":"Expected Outcomes","text":"<p>Confidence oscillates over time, reflecting the solver's self-correcting mechanism. This aligns with TORUS Theory's \\chi-cycle structure.</p>"},{"location":"design_meta_cell/#usage","title":"Usage","text":"<p>To enable the confidence module, wrap the base solver with ConfidencePolicy and use BetaConfidence for tracking.</p> <p>Wrap your solver with <code>ConfidencePolicy</code>:</p> <pre><code>from ai_minesweeper.meta_cell_confidence.policy_wrapper import ConfidencePolicy\nfrom ai_minesweeper.meta_cell_confidence.confidence import BetaConfidence\n\nconfidence = BetaConfidence()\npolicy = ConfidencePolicy(base_solver=RiskAssessor, confidence=confidence)\nmove = policy.choose_move(board)\n</code></pre> <p>See the <code>confidence_oscillation_demo.ipynb</code> notebook for a practical demonstration.</p>"},{"location":"design_meta_cell/#meta-cell-confidence-design","title":"Meta-Cell Confidence Design","text":""},{"location":"design_meta_cell/#overview_1","title":"Overview","text":"<p>The meta-cell confidence module tracks the accuracy of mine-probability predictions and adjusts the solver's risk threshold dynamically. This is inspired by the TORUS \"controller dimension\" concept, which harmonizes observer-state interactions.</p>"},{"location":"design_meta_cell/#key-concepts","title":"Key Concepts","text":"<ul> <li>Beta Confidence: A Beta distribution is used to model prediction confidence.</li> <li>Confidence Policy: Modulates exploration vs. exploitation based on confidence.</li> <li>\u03c7-Cycle: The confidence oscillation period aligns with the \u03c7-cycle (~14 moves).</li> </ul>"},{"location":"design_meta_cell/#motivation-and-theoretical-inspiration","title":"Motivation and Theoretical Inspiration","text":"<p>TORUS Controller Dimension: In TORUS Theory, when a system evolves through 14 recursive layers (0D through 13D), an exact closure is not achieved without an extra adjustment; there\u2019s a fixed phase gap of 360\u00b0/14 in the cycle. TORUS introduces a controller operator $R_{\\text{control}}$ to address this, which is applied at the end of the 13D layer to perfectly \"stitch\" the cycle closed. This operator doesn\u2019t add new physics; it\u2019s a structural, zero-trace transform that compensates the residual error, aligning the end state with the beginning. </p> <p>In our Minesweeper analogy, after a sequence of moves (an analog of a full recursion cycle), the solver may have accumulated a calibration error \u2014 its internal probability estimates might not align with reality. The BetaConfidence component plays the role of $R_{\\text{control}}$: it updates the solver\u2019s state to account for that error, ensuring the next cycle of moves starts with a corrected perspective. In essence, the meta-cell provides the \u201ctwist\u201d that closes the loop of perception and action for the solver, just as $R_{\\text{control}}$ provides the final twist to close TORUS\u2019s 14-layer loop.</p> <p>Ghost-Loop Bicycle Analogy: A riderless bicycle can balance itself only within a narrow speed range, a long-puzzling fact explained by a hidden feedback: the spinning front wheel and the geometry form a toroidal feedback loop that self-corrects the bike\u2019s lean. TORUS modeling showed that the wheel\u2019s gyroscopic effect and the ground contact act like two coupled tori that resonate and stabilize the bike when conditions are right (closing the loop in a 14-layer toroidal lattice). The \u201cghost rider\u201d (no human input) stays up because the system itself provides a corrective torque via this closed flux loop. </p> <p>Our meta-cell is analogous to this ghost torque loop. The solver by itself (like a classical bike model) has no way to adjust if its predictions are systematically off. By adding the meta-cell, we introduce a feedback torque in the form of dynamic policy adjustments: when the solver\u2019s confidence drops, the meta-cell pushes it to explore new areas (a corrective action); when confidence is high, it allows the solver to coast with minimal risk. This feedback ensures stability in performance in much the same way the toroidal loop stabilizes the bicycle. It\u2019s an emergent, second-order effect not present in the base solver, but crucial for self-stability.</p>"},{"location":"design_meta_cell/#implementation-details","title":"Implementation Details","text":"<p>BetaConfidence \u2013 Calibration Tracker: We maintain a Beta distribution $Beta(\\alpha, \\beta)$ that represents the solver\u2019s belief about its own accuracy. Initially $(\\alpha=1, \\beta=1)$ implies no prior bias. After each move: - If the solver\u2019s prediction for that move was correct (e.g., it expected a safe cell and it was safe, or expected a mine and a mine was there), we update $\\alpha \\leftarrow \\alpha + 1$. - If the prediction was wrong, $\\beta \\leftarrow \\beta + 1$. This update rule is a simplified Bayesian calibration: essentially treating each move as a Bernoulli trial of the solver\u2019s prediction skill. The Beta mean $m = \\frac{\\alpha}{\\alpha+\\beta}$ is the solver\u2019s running accuracy estimate. Notably, if the solver is overconfident (making mistakes because it underestimates uncertainties), $m$ will drop below 0.5, which serves as an internal alert that the inference engine is miscalibrated.</p> <p>Over many moves, $\\alpha$ and $\\beta$ grow, and the confidence metric becomes more stable. A well-tuned solver will see $\\alpha$ increase faster than $\\beta$, pushing $m$ toward 1 (but never reaching it if occasional surprises occur). An erratic solver will have $m$ hover low, prompting persistent exploration.</p> <p>ConfidencePolicy \u2013 Dynamic Risk Modulation: The policy uses the BetaConfidence $m$ to set a risk threshold $\\tau$. We define a mapping $\\tau = 0.25 - 0.20 \\cdot m$, which yields $\\tau = 0.25$ when $m = 0$ and $\\tau = 0.05$ when $m = 1$. (Any monotonic function would do; this linear mapping is simple and covers the specified range 5%\u201325%.) Before each move, the solver requests a probability for each unopened cell (the chance that cell hides a mine). The ConfidencePolicy then:</p> <ol> <li>Calculates the current $\\tau$.  </li> <li>Finds all cells with predicted mine probability $p \\le \\tau$. These are \u201csafe enough\u201d to click given the current confidence.  </li> <li>If there is at least one such cell, it chooses the one with the lowest $p$ (maximally safe). If no cell falls below $\\tau$ (meaning the solver is very confident but all moves look dangerous, or the solver is forced to guess), the policy defaults to the least risky cell available (the minimum $p$ overall).</li> </ol> <p>This mechanism ensures a couple of behaviors: - High Confidence (m near 1): $\\tau$ is very low, so the solver will refuse to click anything that isn\u2019t almost certain to be safe. It will only proceed if it finds an extremely low-probability cell. In practical terms, if the solver is doing well, it becomes very selective, avoiding any move that looks even slightly risky. This greediness maximizes the chance of winning when the solver \u201cbelieves\u201d it\u2019s on the right track. - Low Confidence (m drops): $\\tau$ increases, meaning the solver is willing to click cells that have a higher probability of being mines. This might seem counter-intuitive (why click risky cells?), but it\u2019s a form of exploration. A low confidence implies the solver\u2019s model might be wrong or incomplete, so taking a calculated risk can reveal new information and potentially break it out of a situation where it\u2019s stuck or repeatedly wrong. Essentially, the solver becomes curious and experimentally probes the board when it doubts itself.</p>"},{"location":"design_meta_cell/#confidence-visualization","title":"Confidence Visualization","text":"<p>The confidence level of the solver is dynamically displayed in the Streamlit app. This includes:</p> <ul> <li>Metric Display: Shows the current confidence as a percentage.</li> <li>Progress Bar: Provides a visual representation of the confidence level.</li> </ul> <p>These elements update in real-time as the solver makes moves and adjusts its confidence based on outcomes. This feature helps users understand the solver's decision-making process and its calibration over time.</p>"},{"location":"design_meta_cell/#module-path-architecture","title":"Module Path Architecture","text":""},{"location":"design_meta_cell/#architectural-note","title":"Architectural Note","text":"<p>The Minesweeper framework now enforces a single import path for its core module (<code>ai_minesweeper</code>). This is by design, reflecting TORUS Theory\u2019s principle of a single observer-state locus. In practice, it means the codebase is accessed through one coherent package namespace, ensuring consistency (no duplicate modules). This change eliminates ambiguity in the code\u2019s \u201cpoint of view,\u201d analogous to maintaining a single frame of reference for all observations in TORUS\u2019s \u03c7-consistent system.</p>"},{"location":"design_meta_cell/#references","title":"References","text":"<ul> <li>TORUS Theory and Bicycle Self-Stability \u00a73, \u00a74</li> <li>Unified Glossary \u2013 entries \"\u03c7-cycle\", \"Controller Dimension\".</li> </ul>"},{"location":"glossary/","title":"Glossary &amp; FAQ","text":""},{"location":"glossary/#glossary","title":"Glossary","text":""},{"location":"glossary/#-cycle","title":"\u03c7-cycle","text":"<p>Recursive patterns in data, such as prime residue distributions or noise patterns.</p>"},{"location":"glossary/#controller-dimension","title":"Controller Dimension","text":"<p>Theory explaining dynamic stabilization in systems.</p>"},{"location":"glossary/#erc","title":"ERC","text":"<p>Empirical Recursive Cycle, a statistical measure of \u03c7-cycle significance.</p> <p>For more terms, refer to the TORUS Theory paper.</p>"},{"location":"glossary/#faq","title":"FAQ","text":""},{"location":"glossary/#what-is-the-significance-of-8-evidence","title":"What is the significance of 8-\u03c3 evidence?","text":"<p>8-\u03c3 corresponds to a 1 in 10\u00b9\u2075 chance of coincidence, indicating extremely high credibility.</p>"},{"location":"glossary/#how-does-the-controller-dimension-apply-to-hypothesis-solvers","title":"How does the controller dimension apply to hypothesis solvers?","text":"<p>It modulates the solver's risk tolerance, balancing exploration and exploitation phases.</p>"},{"location":"glossary/#what-domains-has-torus-theory-been-validated-in","title":"What domains has TORUS Theory been validated in?","text":"<p>Gravitational wave detectors, prime spirals, and dynamic systems like bicycle stabilization.</p>"},{"location":"gw_validation/","title":"Gravitational Wave Validation","text":"<p>Empirical evidence shows 8-\u03c3 significance of \u03c7-cycle patterns in noise data from gravitational wave detectors.</p>"},{"location":"gw_validation/#key-findings","title":"Key Findings","text":"<ul> <li>Recursive \u03c7-cycle patterns detected in detector noise.</li> <li>Validation performed using statistical analysis.</li> </ul> <p>For detailed results, refer to the validation report.</p>"},{"location":"meg_protocol_outline/","title":"IRB-Ready MEG Protocol Outline","text":""},{"location":"meg_protocol_outline/#objective","title":"Objective","text":"<p>Investigate \u03c7-cycle oscillations in neural activity using MEG.</p>"},{"location":"meg_protocol_outline/#participants","title":"Participants","text":"<ul> <li>20 healthy adults aged 18\u201335.</li> <li>Exclusion criteria: neurological disorders, metal implants.</li> </ul>"},{"location":"meg_protocol_outline/#procedure","title":"Procedure","text":"<ol> <li>Baseline recording: 5 minutes of resting-state MEG.</li> <li>Task phase: Participants play Minesweeper with confidence module active.</li> <li>Post-task recording: 5 minutes of resting-state MEG.</li> </ol>"},{"location":"meg_protocol_outline/#analysis","title":"Analysis","text":"<ul> <li>Time-frequency analysis to detect \u03c7-cycle oscillations (~14 moves).</li> <li>Correlation with confidence scores from the module.</li> </ul>"},{"location":"meg_protocol_outline/#ethical-considerations","title":"Ethical Considerations","text":"<ul> <li>Informed consent.</li> <li>Data anonymization.</li> <li>Compliance with IRB guidelines.</li> </ul>"},{"location":"meta_cell_usage/","title":"Meta-Cell Guide","text":"<p>Learn how to use the Meta-Cell Confidence Module to enhance solver stability.</p>"},{"location":"meta_cell_usage/#features","title":"Features","text":"<ul> <li>Adaptive risk tolerance.</li> <li>Real-time confidence visualization.</li> </ul>"},{"location":"meta_cell_usage/#usage","title":"Usage","text":"<p>Enable the Meta-Cell module in the Streamlit sidebar.</p>"},{"location":"prime_residue/","title":"Prime Residue Analysis","text":"<p>The S-statistic measures variance-to-mean ratio of prime residues modulo 14.</p> Residue Count 0 ... 1 ... ... ... <p>S-statistic: ...</p>"},{"location":"prime_spirals/","title":"Prime Spirals Validation","text":"<p>Prime residue distributions exhibit recursive \u03c7-cycle patterns, matching theoretical predictions.</p>"},{"location":"prime_spirals/#key-findings","title":"Key Findings","text":"<ul> <li>Mod-14 prime spirals demonstrate \u03c7-cycle recursion.</li> <li>Validation performed using computational simulations.</li> </ul> <p>For detailed results, refer to the validation report.</p>"},{"location":"roadmap_overview/","title":"Roadmap Overview","text":""},{"location":"roadmap_overview/#theory","title":"Theory","text":"<p>TORUS Theory introduces recursive self-correction mechanisms in complex systems, leveraging the \u03c7-cycle and controller dimension to stabilize oscillatory behavior.</p>"},{"location":"roadmap_overview/#simulation","title":"Simulation","text":"<p>Simulations validate \u03c7-cycle predictions across domains: - Gravitational wave noise patterns. - Prime residue spirals. - Dynamic systems like bicycle stabilization.</p>"},{"location":"roadmap_overview/#empirical-tests","title":"Empirical Tests","text":"<p>Empirical validations demonstrate 8-\u03c3 evidence: - Gravitational wave detectors: \u03c7-cycle in noise patterns. - Prime spirals: Recursive residue patterns. - Bicycle ghost-rider: Controller dimension stabilization.</p>"},{"location":"roadmap_overview/#open-falsifiers","title":"Open Falsifiers","text":"<p>Future work includes: - Extending \u03c7-cycle predictions to new domains. - Testing controller dimension in protein-folding dynamics. - Exploring legal precedent graphs for recursive patterns.</p>"},{"location":"torus_brot_demo/","title":"TORUS-brot Fractal Demo","text":"<p>Explore the 14-fold \u03c7-recursive fractal generated by the TORUS-brot algorithm.</p> <p></p> <p>This image represents the \u03c7-recursive observer-state projection, demonstrating fractal alignment in Minesweeper theory.</p>"},{"location":"torus_of_tori_and_dpp14/","title":"Torus of Tori and DPP-14","text":"<p>This document provides theoretical background on the Torus-of-Tori architecture and the DPP-14 recursion engine:</p> <ul> <li>Overview of the Torus structure in \u03c7-recursive decision loops</li> <li>Mathematical grounding for Phase Reset Protocol 14 (DPP-14)</li> <li>Interaction between confidence tracking and recursion depth</li> </ul> <p>(Placeholder content \u2014 to be expanded with equations, diagrams, and code examples.)</p>"},{"location":"web_demo/","title":"Web Demo \u2013 TBD","text":""},{"location":"why_torus_matters/","title":"Why TORUS Matters","text":"<p>The \u03c7-cycle and controller dimension principles are central to the Minesweeper Discovery Framework (MDF). These concepts enable hypothesis discovery by transforming complex domains into Minesweeper-style puzzles.</p>"},{"location":"why_torus_matters/#-cycle","title":"\u03c7-cycle","text":"<p>The \u03c7-cycle represents recursive patterns in data, such as prime residue distributions or noise patterns in gravitational wave detectors.</p>"},{"location":"why_torus_matters/#controller-dimension","title":"Controller Dimension","text":"<p>Controller dimension theory explains dynamic stabilization in systems, such as bicycle ghost-rider simulations.</p> <p>For more details, refer to the TORUS Theory paper.</p>"},{"location":"tutorials/discovering_phi_phase_reset/","title":"Discovering \u03c6-Phase Reset","text":"<p>This tutorial explains how to use the Phase-Lock Minesweeper module to detect \u03c6-phase resets in time-series data.</p>"},{"location":"tutorials/discovering_phi_phase_reset/#steps","title":"Steps","text":"<ol> <li>Configure the sampling rate and target frequency in <code>phase_lock_phi_config.yaml</code>.</li> <li>Use the <code>evaluate_cell</code> function to extract 14-cycle segments.</li> <li>Apply the Hilbert transform and compute \u0394\u03c6.</li> <li>Run the Rayleigh test to check for resets.</li> </ol>"},{"location":"tutorials/discovering_phi_phase_reset/#example","title":"Example","text":"<p>Refer to the notebook <code>PhaseLockMinesweeper.ipynb</code> for a demonstration.</p>"},{"location":"tutorials/element_discovery/","title":"Element Discovery Tutorial","text":""},{"location":"tutorials/element_discovery/#overview","title":"Overview","text":"<p>This tutorial demonstrates how the AI Minesweeper Discovery Framework can be applied to uncover missing elements in the periodic table. The periodic table is represented as a grid, where each cell corresponds to an element. Discovered elements are marked as safe, while undiscovered elements are treated as mines.</p>"},{"location":"tutorials/element_discovery/#dataset","title":"Dataset","text":"<p>The dataset used for this demo is <code>examples/boards/elements.csv</code>. It includes: - atomic_number: The atomic number of the element. - symbol: The chemical symbol. - group: The group number in the periodic table. - period: The period number in the periodic table. - is_discovered: A boolean indicating whether the element is discovered.</p>"},{"location":"tutorials/element_discovery/#rules","title":"Rules","text":"<ul> <li>A revealed cell provides a clue indicating the number of undiscovered elements adjacent to it.</li> <li>Adjacent relationships are based on the periodic table layout (groups and periods).</li> </ul>"},{"location":"tutorials/element_discovery/#steps","title":"Steps","text":"<ol> <li>Launch the Streamlit app:    <code>bash    streamlit run streamlit_app.py</code></li> <li>Select \"Periodic Table (Element Discovery)\" from the domain menu.</li> <li>Observe the periodic table grid and interact with the solver to reveal clues and identify undiscovered elements.</li> </ol>"},{"location":"tutorials/element_discovery/#example","title":"Example","text":"<p>Revealing Oxygen (O) might show a clue \"1\", indicating one of its adjacent cells contains an undiscovered element.</p>"},{"location":"tutorials/element_discovery/#notes","title":"Notes","text":"<p>This demo is a simplified representation of the periodic table and is intended for educational purposes.</p>"},{"location":"tutorials/prime_residue_recursion/","title":"Prime Residue Recursion","text":"<p>This tutorial explains how to use the Prime Residue Minesweeper module to analyze prime spirals.</p>"},{"location":"tutorials/prime_residue_recursion/#steps","title":"Steps","text":"<ol> <li>Configure the prime window and \u03c6 constant in <code>primes_chi_config.yaml</code>.</li> <li>Use the <code>build_board</code> function to create a board.</li> <li>Evaluate cells using <code>evaluate_cell</code>.</li> <li>Compute the ridge score using <code>compute_ridge_score</code>.</li> </ol>"},{"location":"tutorials/prime_residue_recursion/#example","title":"Example","text":"<p>Refer to the notebook <code>PrimeResidueMinesweeper.ipynb</code> for a demonstration.</p>"},{"location":"whitepaper_src/whitepage/","title":"What is AI-Minesweeper?","text":"<p>AI-Minesweeper is a hypothesis discovery framework inspired by the classic game Minesweeper. It uses epistemic reasoning to uncover hidden patterns, contradictions, and gaps in structured datasets. The framework is designed to be domain-agnostic, allowing researchers to plug in custom datasets and adjacency logic.</p>"},{"location":"whitepaper_src/whitepage/#plug-in-design","title":"Plug-in Design","text":"<p>The framework supports modular plug-ins for domain-specific logic. Each plug-in defines adjacency rules, clue generation, and hypothesis evaluation tailored to the dataset.</p>"},{"location":"whitepaper_src/whitepage/#demo-list","title":"Demo List","text":"<ul> <li>TORUS Demo: Explore topological patterns.</li> <li>Cymatics Demo: Analyze wave interference data.</li> <li>Prime-Spiral Demo: Investigate prime number distributions.</li> <li>Periodic Table Demo: Discover gaps and anomalies in the periodic table.</li> </ul>"},{"location":"whitepaper_src/whitepage/#torus-integration","title":"TORUS Integration","text":"<p>TORUS is a complementary tool for topological data analysis. AI-Minesweeper integrates with TORUS to enhance hypothesis discovery in spatial datasets.</p>"},{"location":"whitepaper_src/whitepage/#case-study-2-hunting-super-heavy-elements","title":"Case Study 2 \u2013 Hunting Super-Heavy Elements","text":"<p>The periodic-table domain adapter demonstrates hypothesis discovery in nuclear physics. Weighted clues guide the search for unbound isotopes, treating unstable nuclei as mines. This approach highlights gaps in nuclear stability metrics, enabling predictions for super-heavy elements like Z 119\u2013126.</p>"}]}